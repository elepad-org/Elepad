/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * Elepad API
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import { rnFetch } from "../mutator";
export interface Health {
  ok: boolean;
  timestamp: string;
}

export interface User {
  id: string;
  email: string;
  /** @minLength 1 */
  displayName: string;
  /** @nullable */
  avatarUrl: string | null;
  /** @nullable */
  groupId: string | null;
  elder: boolean;
}

/**
 * @nullable
 */
export type ErrorErrorCause = unknown | null;

export type ErrorError = {
  message: string;
  /** @nullable */
  cause?: ErrorErrorCause;
};

export interface Error {
  error: ErrorError;
}

export interface UpdateUser {
  /** @minLength 1 */
  displayName?: string;
  avatarUrl?: string;
}

export interface NewFamilyGroup {
  /** @minLength 1 */
  name: string;
  ownerUserId: string;
}

export interface AddUserWithCode {
  userId: string;
  /** @minLength 1 */
  invitationCode: string;
}

export interface UpdateFamilyGroup {
  /** @minLength 1 */
  name: string;
}

export interface TransferOwnership {
  newOwnerId: string;
}

export interface Activity {
  id: string;
  /** @minLength 1 */
  title: string;
  /** @nullable */
  description?: string | null;
  startsAt: string;
  /** @nullable */
  endsAt?: string | null;
  completed: boolean;
  createdBy: string;
  /** @nullable */
  assignedTo: string | null;
  createdAt: string;
  updatedAt: string;
  /** @nullable */
  frequencyId?: string | null;
}

export interface NewActivity {
  /** @minLength 1 */
  title: string;
  description?: string;
  startsAt: string;
  endsAt?: string;
  completed?: boolean;
  createdBy: string;
  assignedTo: string;
  /** @nullable */
  frequencyId?: string | null;
}

export interface UpdateActivity {
  /** @minLength 1 */
  title?: string;
  description?: string;
  startsAt: string;
  endsAt?: string;
  completed?: boolean;
  assignedTo?: string;
  /** @nullable */
  frequencyId?: string | null;
}

export interface Memory {
  id: string;
  bookId: string;
  groupId: string;
  createdBy: string;
  /** @nullable */
  title: string | null;
  /** @nullable */
  caption: string | null;
  /** @nullable */
  mediaUrl: string | null;
  /** @nullable */
  mimeType: string | null;
  createdAt: string;
}

export interface MemoriesBook {
  id: string;
  groupId: string;
  /** @nullable */
  title: string | null;
  /** @nullable */
  description?: string | null;
  /** @nullable */
  color?: string | null;
  createdAt: string;
  updatedAt?: string;
}

export interface NewMemoriesBook {
  groupId: string;
  /** @minLength 1 */
  title: string;
  description?: string;
  /** @minLength 1 */
  color: string;
}

export interface UpdateMemoriesBook {
  /** @minLength 1 */
  title?: string;
  description?: string;
  /** @minLength 1 */
  color?: string;
}

export interface UpdateMemory {
  /** @minLength 1 */
  title?: string;
  caption?: string;
}

export interface CreateNote {
  bookId: string;
  groupId: string;
  /** @minLength 1 */
  title: string;
  caption?: string;
}

export interface Transcription {
  text: string;
}

export type AlbumWithPagesStatus =
  (typeof AlbumWithPagesStatus)[keyof typeof AlbumWithPagesStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AlbumWithPagesStatus = {
  processing: "processing",
  ready: "ready",
  error: "error",
} as const;

export interface AlbumWithPages {
  id: string;
  groupId: string;
  createdBy: string;
  title: string;
  description: string;
  status: AlbumWithPagesStatus;
  createdAt: string;
  /** @nullable */
  updatedAt: string | null;
  pages: AlbumPage[];
}

export interface AlbumPage {
  id: string;
  albumId: string;
  memoryId: string;
  /** @nullable */
  title: string | null;
  /** @nullable */
  description: string | null;
  order: number;
  createdAt: string;
  /** @nullable */
  updatedAt: string | null;
}

export interface CreateAlbumRequest {
  /**
   * @minLength 1
   * @maxLength 200
   */
  title: string;
  /** @maxLength 1000 */
  description: string;
  /**
   * @minItems 1
   * @maxItems 50
   */
  memoryIds: string[];
}

export type AlbumStatus = (typeof AlbumStatus)[keyof typeof AlbumStatus];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AlbumStatus = {
  processing: "processing",
  ready: "ready",
  error: "error",
} as const;

export interface Album {
  id: string;
  groupId: string;
  createdBy: string;
  title: string;
  /** @nullable */
  description: string | null;
  status: AlbumStatus;
  createdAt: string;
  /** @nullable */
  updatedAt: string | null;
}

export interface Frequency {
  id: string;
  /** @minLength 1 */
  label: string;
  /** @nullable */
  rrule?: string | null;
}

export interface NewFrequency {
  /** @minLength 1 */
  label: string;
  rrule?: string;
}

export interface GameListItem {
  gameType: GameType;
  gameName: string;
  displayName: string;
  description: string;
  icon: string;
  isAvailable: boolean;
  comingSoon?: boolean;
}

export type GameType = (typeof GameType)[keyof typeof GameType];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const GameType = {
  memory: "memory",
  logic: "logic",
  attention: "attention",
  reaction: "reaction",
} as const;

export type MemoryPuzzleCreatedPuzzle = {
  id: string;
  gameType: GameType;
  /** @nullable */
  gameName: string | null;
  /** @nullable */
  title: string | null;
  /** @nullable */
  difficulty: number | null;
  createdAt: string;
};

export type MemoryPuzzleCreatedMemoryGame = {
  puzzleId: string;
  rows: number;
  cols: number;
  symbols: string[];
  layout: number[];
};

export interface MemoryPuzzleCreated {
  puzzle: MemoryPuzzleCreatedPuzzle;
  memoryGame: MemoryPuzzleCreatedMemoryGame;
}

export interface NewMemoryPuzzle {
  title?: string;
  /**
   * @minimum 1
   * @maximum 5
   */
  difficulty?: number;
  /**
   * @minimum 2
   * @maximum 6
   */
  rows?: number;
  /**
   * @minimum 2
   * @maximum 6
   */
  cols?: number;
}

export type NewSudokuPuzzleDifficulty =
  (typeof NewSudokuPuzzleDifficulty)[keyof typeof NewSudokuPuzzleDifficulty];

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const NewSudokuPuzzleDifficulty = {
  easy: "easy",
  medium: "medium",
  hard: "hard",
} as const;

export interface NewSudokuPuzzle {
  title?: string;
  difficulty?: NewSudokuPuzzleDifficulty;
}

export type LogicPuzzleCreatedPuzzle = {
  id: string;
  gameType: GameType;
  /** @nullable */
  gameName: string | null;
  /** @nullable */
  title: string | null;
  /** @nullable */
  difficulty: number | null;
  createdAt: string;
};

export type LogicPuzzleCreatedLogicGameStartStateItem = number | boolean;

export type LogicPuzzleCreatedLogicGameSolutionItem = number | boolean;

export type LogicPuzzleCreatedLogicGame = {
  puzzleId: string;
  rows: number;
  cols: number;
  startState: LogicPuzzleCreatedLogicGameStartStateItem[];
  /** @nullable */
  solution?: LogicPuzzleCreatedLogicGameSolutionItem[] | null;
};

export interface LogicPuzzleCreated {
  puzzle: LogicPuzzleCreatedPuzzle;
  logicGame: LogicPuzzleCreatedLogicGame;
}

export interface NewNetPuzzle {
  title?: string;
  /**
   * @minimum 1
   * @maximum 5
   */
  difficulty?: number;
  /**
   * @minimum 3
   * @maximum 7
   */
  gridSize?: number;
}

export type FocusPuzzleCreatedPuzzle = {
  id: string;
  gameType: GameType;
  /** @nullable */
  gameName: string | null;
  /** @nullable */
  title: string | null;
  /** @nullable */
  difficulty: number | null;
  createdAt: string;
};

export interface FocusPuzzleCreated {
  puzzle: FocusPuzzleCreatedPuzzle;
}

export interface NewFocusPuzzle {
  /**
   * @minimum 1
   * @maximum 100
   */
  rounds?: number;
}

export interface Puzzle {
  id: string;
  gameType: GameType;
  /** @nullable */
  gameName: string | null;
  /** @nullable */
  title: string | null;
  /** @nullable */
  difficulty: number | null;
  createdAt: string;
}

export interface StartAttempt {
  puzzleId: string;
  gameType: GameType;
}

export type FinishAttemptMeta = { [key: string]: unknown | null };

export interface FinishAttempt {
  success: boolean;
  /** @minimum 0 */
  moves: number;
  /** @minimum 0 */
  durationMs: number;
  /** @minimum 0 */
  score?: number;
  meta?: FinishAttemptMeta;
  isFocusGame?: boolean;
  /** @pattern ^\d{4}-\d{2}-\d{2}$ */
  clientDate?: string;
}

/**
 * @nullable
 */
export type AttemptWithUserMeta = { [key: string]: unknown | null } | null;

export type AttemptWithUserUser = {
  displayName: string;
  /** @nullable */
  avatarUrl: string | null;
};

export interface AttemptWithUser {
  id: string;
  userId: string;
  /** @nullable */
  sudokuPuzzleId: string | null;
  /** @nullable */
  memoryPuzzleId: string | null;
  /** @nullable */
  logicPuzzleId: string | null;
  startedAt: string;
  /** @nullable */
  finishedAt: string | null;
  /** @nullable */
  durationMs: number | null;
  /** @nullable */
  score: number | null;
  /** @nullable */
  success: boolean | null;
  /** @nullable */
  moves: number | null;
  /** @nullable */
  meta: AttemptWithUserMeta;
  /** @nullable */
  isFocusGame: boolean | null;
  gameType?: string;
  user?: AttemptWithUserUser;
}

export interface AttemptStats {
  totalAttempts: number;
  successfulAttempts: number;
  failedAttempts: number;
  /** @nullable */
  averageDurationMs: number | null;
  /** @nullable */
  averageMoves: number | null;
  /** @nullable */
  bestScore: number | null;
  /** @nullable */
  bestTime: number | null;
  /** @nullable */
  bestMoves: number | null;
}

export interface AchievementProgress {
  totalAchievements: number;
  unlockedAchievements: number;
  totalPoints: number;
  earnedPoints: number;
}

export type PatchUsersIdAvatarBody = {
  avatarFile?: Blob;
};

export type GetFamilyGroupIdGroupMembers200Owner = {
  id: string;
  displayName: string;
  /** @nullable */
  avatarUrl: string | null;
  elder: boolean;
};

export type GetFamilyGroupIdGroupMembers200MembersItem = {
  id: string;
  displayName: string;
  /** @nullable */
  avatarUrl: string | null;
  elder: boolean;
};

export type GetFamilyGroupIdGroupMembers200 = {
  name: string;
  owner: GetFamilyGroupIdGroupMembers200Owner;
  members: GetFamilyGroupIdGroupMembers200MembersItem[];
};

export type RemoveUserFromFamilyGroupParams = {
  createNewGroup?: string;
};

export type PatchFamilyGroupIdGroup200 = {
  id: string;
  name: string;
  ownerUserId: string;
};

export type TransferFamilyGroupOwnership200Group = {
  id: string;
  name: string;
  ownerUserId: string;
  createdAt: string;
};

export type TransferFamilyGroupOwnership200PreviousOwner = {
  id: string;
};

export type TransferFamilyGroupOwnership200NewOwner = {
  id: string;
  displayName: string;
};

export type TransferFamilyGroupOwnership200 = {
  group: TransferFamilyGroupOwnership200Group;
  previousOwner: TransferFamilyGroupOwnership200PreviousOwner;
  newOwner: TransferFamilyGroupOwnership200NewOwner;
};

export type PostActivitiesGoogleCalendarEnableBody = {
  calendarId?: string;
};

export type PostActivitiesGoogleCalendarEnable200 = {
  success: boolean;
};

export type PostActivitiesGoogleCalendarDisable200 = {
  success: boolean;
};

export type GetActivitiesGoogleCalendarStatus200 = {
  enabled: boolean;
  calendarId?: string;
};

export type GetMemoriesParams = {
  bookId?: string;
  groupId?: string;
  createdBy?: string;
  /**
   * @minimum 0
   * @maximum 100
   * @exclusiveMinimum
   */
  limit?: number;
  /**
   * @minimum 0
   * @nullable
   */
  offset?: number | null;
};

export type GetMemories200 = {
  data: Memory[];
  total: number;
  limit: number;
  offset: number;
};

export type GetMemoriesBooksParams = {
  groupId: string;
};

export type GetMemoriesBooks200 = {
  data: MemoriesBook[];
};

export type CreateMemoryWithMediaBody = {
  bookId: string;
  groupId: string;
  title?: string;
  caption?: string;
  /** Media file to upload (image, video, or audio) */
  image: Blob;
};

export type PostAlbumTranscribeBody = {
  /** Audio file to transcribe (only audio/* allowed) */
  audio: Blob;
};

export type GetAlbumParams = {
  /**
   * @minimum 0
   * @maximum 100
   * @exclusiveMinimum
   */
  limit?: number;
  /**
   * @minimum 0
   * @nullable
   */
  offset?: number | null;
};

export type GetActivityCompletionsParams = {
  /**
   * @pattern ^\d{4}-\d{2}-\d{2}$
   */
  startDate?: string;
  /**
   * @pattern ^\d{4}-\d{2}-\d{2}$
   */
  endDate?: string;
  activityId?: string;
};

export type GetActivityCompletions200DataItem = {
  id: string;
  activityId: string;
  userId: string;
  completedDate: string;
  createdAt: string;
  updatedAt: string;
};

export type GetActivityCompletions200 = {
  data: GetActivityCompletions200DataItem[];
};

export type GetActivityCompletions500 = {
  error: string;
};

export type PostActivityCompletionsToggleBody = {
  activityId: string;
  /** @pattern ^\d{4}-\d{2}-\d{2}$ */
  completedDate: string;
};

/**
 * @nullable
 */
export type PostActivityCompletionsToggle200DataCompletion = {
  id: string;
  activityId: string;
  userId: string;
  completedDate: string;
  createdAt: string;
  updatedAt: string;
} | null;

export type PostActivityCompletionsToggle200Data = {
  completed: boolean;
  /** @nullable */
  completion: PostActivityCompletionsToggle200DataCompletion;
};

export type PostActivityCompletionsToggle200 = {
  data: PostActivityCompletionsToggle200Data;
};

export type PostActivityCompletionsToggle500 = {
  error: string;
};

/**
 * @nullable
 */
export type PostPuzzlesSudoku201 = unknown | null;

export type GetPuzzlesRecentGameTypeParams = {
  /**
   * @minimum 1
   * @maximum 50
   */
  limit?: number;
};

export type PostAttemptsStart201 = {
  id: string;
};

export type PostAttemptsAttemptIdFinish200UnlockedAchievementsItem = {
  id: string;
  code: string;
  title: string;
  description: string;
  /** @nullable */
  icon: string | null;
  points: number;
};

export type PostAttemptsAttemptIdFinish200 = {
  success: boolean;
  score: number;
  unlockedAchievements?: PostAttemptsAttemptIdFinish200UnlockedAchievementsItem[];
};

export type GetAttemptsAttemptId200 = {
  id: string;
};

export type GetAttemptsParams = {
  /**
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
  /**
   * @minimum 0
   * @nullable
   */
  offset?: number | null;
  gameType?: GameType;
  userId?: string;
};

export type GetAttemptsStatsGameTypeParams = {
  userId?: string;
};

export type GetAttemptsLeaderboardGameTypeParams = {
  /**
   * @minimum 1
   * @maximum 50
   */
  limit?: number;
};

export type GetAttemptsLeaderboardGameType200Item = {
  id: string;
  score: number;
};

export type GetAchievementsGameType200Item = {
  id: string;
  title: string;
};

export type GetAchievementsUserGameType200ItemAchievement = {
  id: string;
  title: string;
  description: string;
  /** @nullable */
  icon: string | null;
  points: number;
  gameType: GameType;
  code: string;
};

export type GetAchievementsUserGameType200Item = {
  achievement: GetAchievementsUserGameType200ItemAchievement;
  unlocked: boolean;
  /** @nullable */
  unlockedAt: string | null;
};

export type PostAchievementsCheckAttemptId200Item = {
  id: string;
  title: string;
};

export type GetStreaksMeParams = {
  clientDate?: string;
};

export type GetStreaksMe200 = {
  /** @minimum 0 */
  currentStreak: number;
  /** @minimum 0 */
  longestStreak: number;
  /** @nullable */
  lastPlayedDate: string | null;
};

export type GetStreaksHistoryParams = {
  startDate?: string;
  endDate?: string;
};

export type GetStreaksHistory200 = {
  dates: string[];
};

export type GetNotificationsParams = {
  /**
   * @minimum 1
   * @maximum 100
   */
  limit?: number;
  /**
   * @minimum 0
   * @nullable
   */
  offset?: number | null;
};

export type GetNotifications200Item = {
  id: string;
  user_id: string;
  /** @nullable */
  actor_id: string | null;
  event_type: string;
  entity_type: string;
  entity_id: string;
  /** @nullable */
  title: string | null;
  /** @nullable */
  body: string | null;
  read: boolean;
  created_at: string;
};

export type GetNotificationsUnreadCount200 = {
  count: number;
};

export type PatchNotificationsIdRead200 = {
  success: boolean;
};

export type PatchNotificationsReadAll200 = {
  success: boolean;
};

export type DeleteNotificationsId200 = {
  success: boolean;
};

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export type getHealthResponse200 = {
  data: Health;
  status: 200;
};

export type getHealthResponseSuccess = getHealthResponse200 & {
  headers: Headers;
};
export type getHealthResponse = getHealthResponseSuccess;

export const getGetHealthUrl = () => {
  return `/health`;
};

export const getHealth = async (
  options?: RequestInit,
): Promise<getHealthResponse> => {
  return rnFetch<getHealthResponse>(getGetHealthUrl(), {
    ...options,
    method: "GET",
  });
};

export const getGetHealthQueryKey = () => {
  return [`/health`] as const;
};

export const getGetHealthQueryOptions = <
  TData = Awaited<ReturnType<typeof getHealth>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>
  >;
  request?: SecondParameter<typeof rnFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetHealthQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getHealth>>> = ({
    signal,
  }) => getHealth({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getHealth>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetHealthQueryResult = NonNullable<
  Awaited<ReturnType<typeof getHealth>>
>;
export type GetHealthQueryError = unknown;

export function useGetHealth<
  TData = Awaited<ReturnType<typeof getHealth>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHealth>>,
          TError,
          Awaited<ReturnType<typeof getHealth>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetHealth<
  TData = Awaited<ReturnType<typeof getHealth>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getHealth>>,
          TError,
          Awaited<ReturnType<typeof getHealth>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetHealth<
  TData = Awaited<ReturnType<typeof getHealth>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetHealth<
  TData = Awaited<ReturnType<typeof getHealth>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getHealth>>, TError, TData>
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetHealthQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type getUsersIdResponse200 = {
  data: User;
  status: 200;
};

export type getUsersIdResponse404 = {
  data: void;
  status: 404;
};

export type getUsersIdResponseSuccess = getUsersIdResponse200 & {
  headers: Headers;
};
export type getUsersIdResponseError = getUsersIdResponse404 & {
  headers: Headers;
};

export type getUsersIdResponse =
  | getUsersIdResponseSuccess
  | getUsersIdResponseError;

export const getGetUsersIdUrl = (id: string) => {
  return `/users/${id}`;
};

export const getUsersId = async (
  id: string,
  options?: RequestInit,
): Promise<getUsersIdResponse> => {
  return rnFetch<getUsersIdResponse>(getGetUsersIdUrl(id), {
    ...options,
    method: "GET",
  });
};

export const getGetUsersIdQueryKey = (id?: string) => {
  return [`/users/${id}`] as const;
};

export const getGetUsersIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getUsersId>>,
  TError = void,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUsersId>>, TError, TData>
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUsersIdQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsersId>>> = ({
    signal,
  }) => getUsersId(id, { signal, ...requestOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getUsersId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetUsersIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUsersId>>
>;
export type GetUsersIdQueryError = void;

export function useGetUsersId<
  TData = Awaited<ReturnType<typeof getUsersId>>,
  TError = void,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUsersId>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersId>>,
          TError,
          Awaited<ReturnType<typeof getUsersId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUsersId<
  TData = Awaited<ReturnType<typeof getUsersId>>,
  TError = void,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUsersId>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUsersId>>,
          TError,
          Awaited<ReturnType<typeof getUsersId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetUsersId<
  TData = Awaited<ReturnType<typeof getUsersId>>,
  TError = void,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUsersId>>, TError, TData>
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetUsersId<
  TData = Awaited<ReturnType<typeof getUsersId>>,
  TError = void,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUsersId>>, TError, TData>
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetUsersIdQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type patchUsersIdResponse200 = {
  data: User;
  status: 200;
};

export type patchUsersIdResponse400 = {
  data: Error;
  status: 400;
};

export type patchUsersIdResponse404 = {
  data: Error;
  status: 404;
};

export type patchUsersIdResponse500 = {
  data: Error;
  status: 500;
};

export type patchUsersIdResponseSuccess = patchUsersIdResponse200 & {
  headers: Headers;
};
export type patchUsersIdResponseError = (
  | patchUsersIdResponse400
  | patchUsersIdResponse404
  | patchUsersIdResponse500
) & {
  headers: Headers;
};

export type patchUsersIdResponse =
  | patchUsersIdResponseSuccess
  | patchUsersIdResponseError;

export const getPatchUsersIdUrl = (id: string) => {
  return `/users/${id}`;
};

export const patchUsersId = async (
  id: string,
  updateUser: UpdateUser,
  options?: RequestInit,
): Promise<patchUsersIdResponse> => {
  return rnFetch<patchUsersIdResponse>(getPatchUsersIdUrl(id), {
    ...options,
    method: "PATCH",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(updateUser),
  });
};

export const getPatchUsersIdMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patchUsersId>>,
    TError,
    { id: string; data: UpdateUser },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patchUsersId>>,
  TError,
  { id: string; data: UpdateUser },
  TContext
> => {
  const mutationKey = ["patchUsersId"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patchUsersId>>,
    { id: string; data: UpdateUser }
  > = (props) => {
    const { id, data } = props ?? {};

    return patchUsersId(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatchUsersIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof patchUsersId>>
>;
export type PatchUsersIdMutationBody = UpdateUser;
export type PatchUsersIdMutationError = Error;

export const usePatchUsersId = <TError = Error, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof patchUsersId>>,
      TError,
      { id: string; data: UpdateUser },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof patchUsersId>>,
  TError,
  { id: string; data: UpdateUser },
  TContext
> => {
  const mutationOptions = getPatchUsersIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type patchUsersIdAvatarResponse200 = {
  data: User;
  status: 200;
};

export type patchUsersIdAvatarResponse400 = {
  data: Error;
  status: 400;
};

export type patchUsersIdAvatarResponse404 = {
  data: Error;
  status: 404;
};

export type patchUsersIdAvatarResponse500 = {
  data: Error;
  status: 500;
};

export type patchUsersIdAvatarResponseSuccess =
  patchUsersIdAvatarResponse200 & {
    headers: Headers;
  };
export type patchUsersIdAvatarResponseError = (
  | patchUsersIdAvatarResponse400
  | patchUsersIdAvatarResponse404
  | patchUsersIdAvatarResponse500
) & {
  headers: Headers;
};

export type patchUsersIdAvatarResponse =
  | patchUsersIdAvatarResponseSuccess
  | patchUsersIdAvatarResponseError;

export const getPatchUsersIdAvatarUrl = (id: string) => {
  return `/users/${id}/avatar`;
};

export const patchUsersIdAvatar = async (
  id: string,
  patchUsersIdAvatarBody: PatchUsersIdAvatarBody,
  options?: RequestInit,
): Promise<patchUsersIdAvatarResponse> => {
  const formData = new FormData();
  if (patchUsersIdAvatarBody.avatarFile !== undefined) {
    formData.append(`avatarFile`, patchUsersIdAvatarBody.avatarFile);
  }

  return rnFetch<patchUsersIdAvatarResponse>(getPatchUsersIdAvatarUrl(id), {
    ...options,
    method: "PATCH",
    body: formData,
  });
};

export const getPatchUsersIdAvatarMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patchUsersIdAvatar>>,
    TError,
    { id: string; data: PatchUsersIdAvatarBody },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patchUsersIdAvatar>>,
  TError,
  { id: string; data: PatchUsersIdAvatarBody },
  TContext
> => {
  const mutationKey = ["patchUsersIdAvatar"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patchUsersIdAvatar>>,
    { id: string; data: PatchUsersIdAvatarBody }
  > = (props) => {
    const { id, data } = props ?? {};

    return patchUsersIdAvatar(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatchUsersIdAvatarMutationResult = NonNullable<
  Awaited<ReturnType<typeof patchUsersIdAvatar>>
>;
export type PatchUsersIdAvatarMutationBody = PatchUsersIdAvatarBody;
export type PatchUsersIdAvatarMutationError = Error;

export const usePatchUsersIdAvatar = <TError = Error, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof patchUsersIdAvatar>>,
      TError,
      { id: string; data: PatchUsersIdAvatarBody },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof patchUsersIdAvatar>>,
  TError,
  { id: string; data: PatchUsersIdAvatarBody },
  TContext
> => {
  const mutationOptions = getPatchUsersIdAvatarMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type postFamilyGroupCreateResponse201 = {
  data: void;
  status: 201;
};

export type postFamilyGroupCreateResponse400 = {
  data: Error;
  status: 400;
};

export type postFamilyGroupCreateResponse500 = {
  data: Error;
  status: 500;
};

export type postFamilyGroupCreateResponseSuccess =
  postFamilyGroupCreateResponse201 & {
    headers: Headers;
  };
export type postFamilyGroupCreateResponseError = (
  | postFamilyGroupCreateResponse400
  | postFamilyGroupCreateResponse500
) & {
  headers: Headers;
};

export type postFamilyGroupCreateResponse =
  | postFamilyGroupCreateResponseSuccess
  | postFamilyGroupCreateResponseError;

export const getPostFamilyGroupCreateUrl = () => {
  return `/familyGroup/create`;
};

export const postFamilyGroupCreate = async (
  newFamilyGroup: NewFamilyGroup,
  options?: RequestInit,
): Promise<postFamilyGroupCreateResponse> => {
  return rnFetch<postFamilyGroupCreateResponse>(getPostFamilyGroupCreateUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(newFamilyGroup),
  });
};

export const getPostFamilyGroupCreateMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postFamilyGroupCreate>>,
    TError,
    { data: NewFamilyGroup },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postFamilyGroupCreate>>,
  TError,
  { data: NewFamilyGroup },
  TContext
> => {
  const mutationKey = ["postFamilyGroupCreate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postFamilyGroupCreate>>,
    { data: NewFamilyGroup }
  > = (props) => {
    const { data } = props ?? {};

    return postFamilyGroupCreate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostFamilyGroupCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof postFamilyGroupCreate>>
>;
export type PostFamilyGroupCreateMutationBody = NewFamilyGroup;
export type PostFamilyGroupCreateMutationError = Error;

export const usePostFamilyGroupCreate = <TError = Error, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postFamilyGroupCreate>>,
      TError,
      { data: NewFamilyGroup },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postFamilyGroupCreate>>,
  TError,
  { data: NewFamilyGroup },
  TContext
> => {
  const mutationOptions = getPostFamilyGroupCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type postFamilyGroupLinkResponse200 = {
  data: void;
  status: 200;
};

export type postFamilyGroupLinkResponse400 = {
  data: Error;
  status: 400;
};

export type postFamilyGroupLinkResponse404 = {
  data: Error;
  status: 404;
};

export type postFamilyGroupLinkResponse500 = {
  data: Error;
  status: 500;
};

export type postFamilyGroupLinkResponseSuccess =
  postFamilyGroupLinkResponse200 & {
    headers: Headers;
  };
export type postFamilyGroupLinkResponseError = (
  | postFamilyGroupLinkResponse400
  | postFamilyGroupLinkResponse404
  | postFamilyGroupLinkResponse500
) & {
  headers: Headers;
};

export type postFamilyGroupLinkResponse =
  | postFamilyGroupLinkResponseSuccess
  | postFamilyGroupLinkResponseError;

export const getPostFamilyGroupLinkUrl = () => {
  return `/familyGroup/link`;
};

export const postFamilyGroupLink = async (
  addUserWithCode: AddUserWithCode,
  options?: RequestInit,
): Promise<postFamilyGroupLinkResponse> => {
  return rnFetch<postFamilyGroupLinkResponse>(getPostFamilyGroupLinkUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(addUserWithCode),
  });
};

export const getPostFamilyGroupLinkMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postFamilyGroupLink>>,
    TError,
    { data: AddUserWithCode },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postFamilyGroupLink>>,
  TError,
  { data: AddUserWithCode },
  TContext
> => {
  const mutationKey = ["postFamilyGroupLink"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postFamilyGroupLink>>,
    { data: AddUserWithCode }
  > = (props) => {
    const { data } = props ?? {};

    return postFamilyGroupLink(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostFamilyGroupLinkMutationResult = NonNullable<
  Awaited<ReturnType<typeof postFamilyGroupLink>>
>;
export type PostFamilyGroupLinkMutationBody = AddUserWithCode;
export type PostFamilyGroupLinkMutationError = Error;

export const usePostFamilyGroupLink = <TError = Error, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postFamilyGroupLink>>,
      TError,
      { data: AddUserWithCode },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postFamilyGroupLink>>,
  TError,
  { data: AddUserWithCode },
  TContext
> => {
  const mutationOptions = getPostFamilyGroupLinkMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type getFamilyGroupIdGroupInviteResponse200 = {
  data: void;
  status: 200;
};

export type getFamilyGroupIdGroupInviteResponse400 = {
  data: Error;
  status: 400;
};

export type getFamilyGroupIdGroupInviteResponse404 = {
  data: Error;
  status: 404;
};

export type getFamilyGroupIdGroupInviteResponse500 = {
  data: Error;
  status: 500;
};

export type getFamilyGroupIdGroupInviteResponseSuccess =
  getFamilyGroupIdGroupInviteResponse200 & {
    headers: Headers;
  };
export type getFamilyGroupIdGroupInviteResponseError = (
  | getFamilyGroupIdGroupInviteResponse400
  | getFamilyGroupIdGroupInviteResponse404
  | getFamilyGroupIdGroupInviteResponse500
) & {
  headers: Headers;
};

export type getFamilyGroupIdGroupInviteResponse =
  | getFamilyGroupIdGroupInviteResponseSuccess
  | getFamilyGroupIdGroupInviteResponseError;

export const getGetFamilyGroupIdGroupInviteUrl = (idGroup: string) => {
  return `/familyGroup/${idGroup}/invite`;
};

export const getFamilyGroupIdGroupInvite = async (
  idGroup: string,
  options?: RequestInit,
): Promise<getFamilyGroupIdGroupInviteResponse> => {
  return rnFetch<getFamilyGroupIdGroupInviteResponse>(
    getGetFamilyGroupIdGroupInviteUrl(idGroup),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetFamilyGroupIdGroupInviteQueryKey = (idGroup?: string) => {
  return [`/familyGroup/${idGroup}/invite`] as const;
};

export const getGetFamilyGroupIdGroupInviteQueryOptions = <
  TData = Awaited<ReturnType<typeof getFamilyGroupIdGroupInvite>>,
  TError = Error,
>(
  idGroup: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFamilyGroupIdGroupInvite>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetFamilyGroupIdGroupInviteQueryKey(idGroup);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getFamilyGroupIdGroupInvite>>
  > = ({ signal }) =>
    getFamilyGroupIdGroupInvite(idGroup, { signal, ...requestOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!idGroup,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getFamilyGroupIdGroupInvite>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetFamilyGroupIdGroupInviteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFamilyGroupIdGroupInvite>>
>;
export type GetFamilyGroupIdGroupInviteQueryError = Error;

export function useGetFamilyGroupIdGroupInvite<
  TData = Awaited<ReturnType<typeof getFamilyGroupIdGroupInvite>>,
  TError = Error,
>(
  idGroup: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFamilyGroupIdGroupInvite>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFamilyGroupIdGroupInvite>>,
          TError,
          Awaited<ReturnType<typeof getFamilyGroupIdGroupInvite>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFamilyGroupIdGroupInvite<
  TData = Awaited<ReturnType<typeof getFamilyGroupIdGroupInvite>>,
  TError = Error,
>(
  idGroup: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFamilyGroupIdGroupInvite>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFamilyGroupIdGroupInvite>>,
          TError,
          Awaited<ReturnType<typeof getFamilyGroupIdGroupInvite>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFamilyGroupIdGroupInvite<
  TData = Awaited<ReturnType<typeof getFamilyGroupIdGroupInvite>>,
  TError = Error,
>(
  idGroup: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFamilyGroupIdGroupInvite>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetFamilyGroupIdGroupInvite<
  TData = Awaited<ReturnType<typeof getFamilyGroupIdGroupInvite>>,
  TError = Error,
>(
  idGroup: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFamilyGroupIdGroupInvite>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetFamilyGroupIdGroupInviteQueryOptions(
    idGroup,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type getFamilyGroupIdGroupMembersResponse200 = {
  data: GetFamilyGroupIdGroupMembers200;
  status: 200;
};

export type getFamilyGroupIdGroupMembersResponse400 = {
  data: Error;
  status: 400;
};

export type getFamilyGroupIdGroupMembersResponse404 = {
  data: Error;
  status: 404;
};

export type getFamilyGroupIdGroupMembersResponse500 = {
  data: Error;
  status: 500;
};

export type getFamilyGroupIdGroupMembersResponseSuccess =
  getFamilyGroupIdGroupMembersResponse200 & {
    headers: Headers;
  };
export type getFamilyGroupIdGroupMembersResponseError = (
  | getFamilyGroupIdGroupMembersResponse400
  | getFamilyGroupIdGroupMembersResponse404
  | getFamilyGroupIdGroupMembersResponse500
) & {
  headers: Headers;
};

export type getFamilyGroupIdGroupMembersResponse =
  | getFamilyGroupIdGroupMembersResponseSuccess
  | getFamilyGroupIdGroupMembersResponseError;

export const getGetFamilyGroupIdGroupMembersUrl = (idGroup: string) => {
  return `/familyGroup/${idGroup}/members`;
};

export const getFamilyGroupIdGroupMembers = async (
  idGroup: string,
  options?: RequestInit,
): Promise<getFamilyGroupIdGroupMembersResponse> => {
  return rnFetch<getFamilyGroupIdGroupMembersResponse>(
    getGetFamilyGroupIdGroupMembersUrl(idGroup),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetFamilyGroupIdGroupMembersQueryKey = (idGroup?: string) => {
  return [`/familyGroup/${idGroup}/members`] as const;
};

export const getGetFamilyGroupIdGroupMembersQueryOptions = <
  TData = Awaited<ReturnType<typeof getFamilyGroupIdGroupMembers>>,
  TError = Error,
>(
  idGroup: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFamilyGroupIdGroupMembers>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetFamilyGroupIdGroupMembersQueryKey(idGroup);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getFamilyGroupIdGroupMembers>>
  > = ({ signal }) =>
    getFamilyGroupIdGroupMembers(idGroup, { signal, ...requestOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!idGroup,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getFamilyGroupIdGroupMembers>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetFamilyGroupIdGroupMembersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFamilyGroupIdGroupMembers>>
>;
export type GetFamilyGroupIdGroupMembersQueryError = Error;

export function useGetFamilyGroupIdGroupMembers<
  TData = Awaited<ReturnType<typeof getFamilyGroupIdGroupMembers>>,
  TError = Error,
>(
  idGroup: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFamilyGroupIdGroupMembers>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFamilyGroupIdGroupMembers>>,
          TError,
          Awaited<ReturnType<typeof getFamilyGroupIdGroupMembers>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFamilyGroupIdGroupMembers<
  TData = Awaited<ReturnType<typeof getFamilyGroupIdGroupMembers>>,
  TError = Error,
>(
  idGroup: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFamilyGroupIdGroupMembers>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFamilyGroupIdGroupMembers>>,
          TError,
          Awaited<ReturnType<typeof getFamilyGroupIdGroupMembers>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFamilyGroupIdGroupMembers<
  TData = Awaited<ReturnType<typeof getFamilyGroupIdGroupMembers>>,
  TError = Error,
>(
  idGroup: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFamilyGroupIdGroupMembers>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetFamilyGroupIdGroupMembers<
  TData = Awaited<ReturnType<typeof getFamilyGroupIdGroupMembers>>,
  TError = Error,
>(
  idGroup: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFamilyGroupIdGroupMembers>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetFamilyGroupIdGroupMembersQueryOptions(
    idGroup,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type removeUserFromFamilyGroupResponse200 = {
  data: void;
  status: 200;
};

export type removeUserFromFamilyGroupResponse400 = {
  data: Error;
  status: 400;
};

export type removeUserFromFamilyGroupResponse401 = {
  data: Error;
  status: 401;
};

export type removeUserFromFamilyGroupResponse403 = {
  data: Error;
  status: 403;
};

export type removeUserFromFamilyGroupResponse404 = {
  data: Error;
  status: 404;
};

export type removeUserFromFamilyGroupResponse500 = {
  data: Error;
  status: 500;
};

export type removeUserFromFamilyGroupResponseSuccess =
  removeUserFromFamilyGroupResponse200 & {
    headers: Headers;
  };
export type removeUserFromFamilyGroupResponseError = (
  | removeUserFromFamilyGroupResponse400
  | removeUserFromFamilyGroupResponse401
  | removeUserFromFamilyGroupResponse403
  | removeUserFromFamilyGroupResponse404
  | removeUserFromFamilyGroupResponse500
) & {
  headers: Headers;
};

export type removeUserFromFamilyGroupResponse =
  | removeUserFromFamilyGroupResponseSuccess
  | removeUserFromFamilyGroupResponseError;

export const getRemoveUserFromFamilyGroupUrl = (
  idGroup: string,
  idUser: string,
  params?: RemoveUserFromFamilyGroupParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/familyGroup/${idGroup}/member/${idUser}?${stringifiedParams}`
    : `/familyGroup/${idGroup}/member/${idUser}`;
};

export const removeUserFromFamilyGroup = async (
  idGroup: string,
  idUser: string,
  params?: RemoveUserFromFamilyGroupParams,
  options?: RequestInit,
): Promise<removeUserFromFamilyGroupResponse> => {
  return rnFetch<removeUserFromFamilyGroupResponse>(
    getRemoveUserFromFamilyGroupUrl(idGroup, idUser, params),
    {
      ...options,
      method: "DELETE",
    },
  );
};

export const getRemoveUserFromFamilyGroupMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof removeUserFromFamilyGroup>>,
    TError,
    {
      idGroup: string;
      idUser: string;
      params?: RemoveUserFromFamilyGroupParams;
    },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof removeUserFromFamilyGroup>>,
  TError,
  { idGroup: string; idUser: string; params?: RemoveUserFromFamilyGroupParams },
  TContext
> => {
  const mutationKey = ["removeUserFromFamilyGroup"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeUserFromFamilyGroup>>,
    {
      idGroup: string;
      idUser: string;
      params?: RemoveUserFromFamilyGroupParams;
    }
  > = (props) => {
    const { idGroup, idUser, params } = props ?? {};

    return removeUserFromFamilyGroup(idGroup, idUser, params, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type RemoveUserFromFamilyGroupMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeUserFromFamilyGroup>>
>;

export type RemoveUserFromFamilyGroupMutationError = Error;

export const useRemoveUserFromFamilyGroup = <
  TError = Error,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeUserFromFamilyGroup>>,
      TError,
      {
        idGroup: string;
        idUser: string;
        params?: RemoveUserFromFamilyGroupParams;
      },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof removeUserFromFamilyGroup>>,
  TError,
  { idGroup: string; idUser: string; params?: RemoveUserFromFamilyGroupParams },
  TContext
> => {
  const mutationOptions = getRemoveUserFromFamilyGroupMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type patchFamilyGroupIdGroupResponse200 = {
  data: PatchFamilyGroupIdGroup200;
  status: 200;
};

export type patchFamilyGroupIdGroupResponse400 = {
  data: Error;
  status: 400;
};

export type patchFamilyGroupIdGroupResponse404 = {
  data: Error;
  status: 404;
};

export type patchFamilyGroupIdGroupResponse500 = {
  data: Error;
  status: 500;
};

export type patchFamilyGroupIdGroupResponseSuccess =
  patchFamilyGroupIdGroupResponse200 & {
    headers: Headers;
  };
export type patchFamilyGroupIdGroupResponseError = (
  | patchFamilyGroupIdGroupResponse400
  | patchFamilyGroupIdGroupResponse404
  | patchFamilyGroupIdGroupResponse500
) & {
  headers: Headers;
};

export type patchFamilyGroupIdGroupResponse =
  | patchFamilyGroupIdGroupResponseSuccess
  | patchFamilyGroupIdGroupResponseError;

export const getPatchFamilyGroupIdGroupUrl = (idGroup: string) => {
  return `/familyGroup/${idGroup}`;
};

export const patchFamilyGroupIdGroup = async (
  idGroup: string,
  updateFamilyGroup: UpdateFamilyGroup,
  options?: RequestInit,
): Promise<patchFamilyGroupIdGroupResponse> => {
  return rnFetch<patchFamilyGroupIdGroupResponse>(
    getPatchFamilyGroupIdGroupUrl(idGroup),
    {
      ...options,
      method: "PATCH",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(updateFamilyGroup),
    },
  );
};

export const getPatchFamilyGroupIdGroupMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patchFamilyGroupIdGroup>>,
    TError,
    { idGroup: string; data: UpdateFamilyGroup },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patchFamilyGroupIdGroup>>,
  TError,
  { idGroup: string; data: UpdateFamilyGroup },
  TContext
> => {
  const mutationKey = ["patchFamilyGroupIdGroup"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patchFamilyGroupIdGroup>>,
    { idGroup: string; data: UpdateFamilyGroup }
  > = (props) => {
    const { idGroup, data } = props ?? {};

    return patchFamilyGroupIdGroup(idGroup, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatchFamilyGroupIdGroupMutationResult = NonNullable<
  Awaited<ReturnType<typeof patchFamilyGroupIdGroup>>
>;
export type PatchFamilyGroupIdGroupMutationBody = UpdateFamilyGroup;
export type PatchFamilyGroupIdGroupMutationError = Error;

export const usePatchFamilyGroupIdGroup = <TError = Error, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof patchFamilyGroupIdGroup>>,
      TError,
      { idGroup: string; data: UpdateFamilyGroup },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof patchFamilyGroupIdGroup>>,
  TError,
  { idGroup: string; data: UpdateFamilyGroup },
  TContext
> => {
  const mutationOptions = getPatchFamilyGroupIdGroupMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type transferFamilyGroupOwnershipResponse200 = {
  data: TransferFamilyGroupOwnership200;
  status: 200;
};

export type transferFamilyGroupOwnershipResponse400 = {
  data: Error;
  status: 400;
};

export type transferFamilyGroupOwnershipResponse401 = {
  data: Error;
  status: 401;
};

export type transferFamilyGroupOwnershipResponse403 = {
  data: Error;
  status: 403;
};

export type transferFamilyGroupOwnershipResponse404 = {
  data: Error;
  status: 404;
};

export type transferFamilyGroupOwnershipResponse500 = {
  data: Error;
  status: 500;
};

export type transferFamilyGroupOwnershipResponseSuccess =
  transferFamilyGroupOwnershipResponse200 & {
    headers: Headers;
  };
export type transferFamilyGroupOwnershipResponseError = (
  | transferFamilyGroupOwnershipResponse400
  | transferFamilyGroupOwnershipResponse401
  | transferFamilyGroupOwnershipResponse403
  | transferFamilyGroupOwnershipResponse404
  | transferFamilyGroupOwnershipResponse500
) & {
  headers: Headers;
};

export type transferFamilyGroupOwnershipResponse =
  | transferFamilyGroupOwnershipResponseSuccess
  | transferFamilyGroupOwnershipResponseError;

export const getTransferFamilyGroupOwnershipUrl = (idGroup: string) => {
  return `/familyGroup/${idGroup}/transfer-ownership`;
};

export const transferFamilyGroupOwnership = async (
  idGroup: string,
  transferOwnership: TransferOwnership,
  options?: RequestInit,
): Promise<transferFamilyGroupOwnershipResponse> => {
  return rnFetch<transferFamilyGroupOwnershipResponse>(
    getTransferFamilyGroupOwnershipUrl(idGroup),
    {
      ...options,
      method: "PUT",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(transferOwnership),
    },
  );
};

export const getTransferFamilyGroupOwnershipMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof transferFamilyGroupOwnership>>,
    TError,
    { idGroup: string; data: TransferOwnership },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof transferFamilyGroupOwnership>>,
  TError,
  { idGroup: string; data: TransferOwnership },
  TContext
> => {
  const mutationKey = ["transferFamilyGroupOwnership"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof transferFamilyGroupOwnership>>,
    { idGroup: string; data: TransferOwnership }
  > = (props) => {
    const { idGroup, data } = props ?? {};

    return transferFamilyGroupOwnership(idGroup, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type TransferFamilyGroupOwnershipMutationResult = NonNullable<
  Awaited<ReturnType<typeof transferFamilyGroupOwnership>>
>;
export type TransferFamilyGroupOwnershipMutationBody = TransferOwnership;
export type TransferFamilyGroupOwnershipMutationError = Error;

export const useTransferFamilyGroupOwnership = <
  TError = Error,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof transferFamilyGroupOwnership>>,
      TError,
      { idGroup: string; data: TransferOwnership },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof transferFamilyGroupOwnership>>,
  TError,
  { idGroup: string; data: TransferOwnership },
  TContext
> => {
  const mutationOptions =
    getTransferFamilyGroupOwnershipMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type getActivitiesIdResponse200 = {
  data: Activity;
  status: 200;
};

export type getActivitiesIdResponse404 = {
  data: Error;
  status: 404;
};

export type getActivitiesIdResponse500 = {
  data: Error;
  status: 500;
};

export type getActivitiesIdResponseSuccess = getActivitiesIdResponse200 & {
  headers: Headers;
};
export type getActivitiesIdResponseError = (
  | getActivitiesIdResponse404
  | getActivitiesIdResponse500
) & {
  headers: Headers;
};

export type getActivitiesIdResponse =
  | getActivitiesIdResponseSuccess
  | getActivitiesIdResponseError;

export const getGetActivitiesIdUrl = (id: string) => {
  return `/activities/${id}`;
};

export const getActivitiesId = async (
  id: string,
  options?: RequestInit,
): Promise<getActivitiesIdResponse> => {
  return rnFetch<getActivitiesIdResponse>(getGetActivitiesIdUrl(id), {
    ...options,
    method: "GET",
  });
};

export const getGetActivitiesIdQueryKey = (id?: string) => {
  return [`/activities/${id}`] as const;
};

export const getGetActivitiesIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getActivitiesId>>,
  TError = Error,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActivitiesId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetActivitiesIdQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getActivitiesId>>> = ({
    signal,
  }) => getActivitiesId(id, { signal, ...requestOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getActivitiesId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetActivitiesIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getActivitiesId>>
>;
export type GetActivitiesIdQueryError = Error;

export function useGetActivitiesId<
  TData = Awaited<ReturnType<typeof getActivitiesId>>,
  TError = Error,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActivitiesId>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActivitiesId>>,
          TError,
          Awaited<ReturnType<typeof getActivitiesId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetActivitiesId<
  TData = Awaited<ReturnType<typeof getActivitiesId>>,
  TError = Error,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActivitiesId>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActivitiesId>>,
          TError,
          Awaited<ReturnType<typeof getActivitiesId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetActivitiesId<
  TData = Awaited<ReturnType<typeof getActivitiesId>>,
  TError = Error,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActivitiesId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetActivitiesId<
  TData = Awaited<ReturnType<typeof getActivitiesId>>,
  TError = Error,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActivitiesId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetActivitiesIdQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type patchActivitiesIdResponse200 = {
  data: Activity;
  status: 200;
};

export type patchActivitiesIdResponse400 = {
  data: Error;
  status: 400;
};

export type patchActivitiesIdResponse404 = {
  data: Error;
  status: 404;
};

export type patchActivitiesIdResponse500 = {
  data: Error;
  status: 500;
};

export type patchActivitiesIdResponseSuccess = patchActivitiesIdResponse200 & {
  headers: Headers;
};
export type patchActivitiesIdResponseError = (
  | patchActivitiesIdResponse400
  | patchActivitiesIdResponse404
  | patchActivitiesIdResponse500
) & {
  headers: Headers;
};

export type patchActivitiesIdResponse =
  | patchActivitiesIdResponseSuccess
  | patchActivitiesIdResponseError;

export const getPatchActivitiesIdUrl = (id: string) => {
  return `/activities/${id}`;
};

export const patchActivitiesId = async (
  id: string,
  updateActivity: UpdateActivity,
  options?: RequestInit,
): Promise<patchActivitiesIdResponse> => {
  return rnFetch<patchActivitiesIdResponse>(getPatchActivitiesIdUrl(id), {
    ...options,
    method: "PATCH",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(updateActivity),
  });
};

export const getPatchActivitiesIdMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patchActivitiesId>>,
    TError,
    { id: string; data: UpdateActivity },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patchActivitiesId>>,
  TError,
  { id: string; data: UpdateActivity },
  TContext
> => {
  const mutationKey = ["patchActivitiesId"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patchActivitiesId>>,
    { id: string; data: UpdateActivity }
  > = (props) => {
    const { id, data } = props ?? {};

    return patchActivitiesId(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatchActivitiesIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof patchActivitiesId>>
>;
export type PatchActivitiesIdMutationBody = UpdateActivity;
export type PatchActivitiesIdMutationError = Error;

export const usePatchActivitiesId = <TError = Error, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof patchActivitiesId>>,
      TError,
      { id: string; data: UpdateActivity },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof patchActivitiesId>>,
  TError,
  { id: string; data: UpdateActivity },
  TContext
> => {
  const mutationOptions = getPatchActivitiesIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type deleteActivitiesIdResponse204 = {
  data: void;
  status: 204;
};

export type deleteActivitiesIdResponse404 = {
  data: Error;
  status: 404;
};

export type deleteActivitiesIdResponse500 = {
  data: Error;
  status: 500;
};

export type deleteActivitiesIdResponseSuccess =
  deleteActivitiesIdResponse204 & {
    headers: Headers;
  };
export type deleteActivitiesIdResponseError = (
  | deleteActivitiesIdResponse404
  | deleteActivitiesIdResponse500
) & {
  headers: Headers;
};

export type deleteActivitiesIdResponse =
  | deleteActivitiesIdResponseSuccess
  | deleteActivitiesIdResponseError;

export const getDeleteActivitiesIdUrl = (id: string) => {
  return `/activities/${id}`;
};

export const deleteActivitiesId = async (
  id: string,
  options?: RequestInit,
): Promise<deleteActivitiesIdResponse> => {
  return rnFetch<deleteActivitiesIdResponse>(getDeleteActivitiesIdUrl(id), {
    ...options,
    method: "DELETE",
  });
};

export const getDeleteActivitiesIdMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteActivitiesId>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteActivitiesId>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ["deleteActivitiesId"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteActivitiesId>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return deleteActivitiesId(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteActivitiesIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteActivitiesId>>
>;

export type DeleteActivitiesIdMutationError = Error;

export const useDeleteActivitiesId = <TError = Error, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteActivitiesId>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteActivitiesId>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteActivitiesIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type getActivitiesFamilyCodeIdFamilyGroupResponse200 = {
  data: Activity[];
  status: 200;
};

export type getActivitiesFamilyCodeIdFamilyGroupResponse404 = {
  data: Error;
  status: 404;
};

export type getActivitiesFamilyCodeIdFamilyGroupResponse500 = {
  data: Error;
  status: 500;
};

export type getActivitiesFamilyCodeIdFamilyGroupResponseSuccess =
  getActivitiesFamilyCodeIdFamilyGroupResponse200 & {
    headers: Headers;
  };
export type getActivitiesFamilyCodeIdFamilyGroupResponseError = (
  | getActivitiesFamilyCodeIdFamilyGroupResponse404
  | getActivitiesFamilyCodeIdFamilyGroupResponse500
) & {
  headers: Headers;
};

export type getActivitiesFamilyCodeIdFamilyGroupResponse =
  | getActivitiesFamilyCodeIdFamilyGroupResponseSuccess
  | getActivitiesFamilyCodeIdFamilyGroupResponseError;

export const getGetActivitiesFamilyCodeIdFamilyGroupUrl = (
  idFamilyGroup: string,
) => {
  return `/activities/familyCode/${idFamilyGroup}`;
};

export const getActivitiesFamilyCodeIdFamilyGroup = async (
  idFamilyGroup: string,
  options?: RequestInit,
): Promise<getActivitiesFamilyCodeIdFamilyGroupResponse> => {
  return rnFetch<getActivitiesFamilyCodeIdFamilyGroupResponse>(
    getGetActivitiesFamilyCodeIdFamilyGroupUrl(idFamilyGroup),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetActivitiesFamilyCodeIdFamilyGroupQueryKey = (
  idFamilyGroup?: string,
) => {
  return [`/activities/familyCode/${idFamilyGroup}`] as const;
};

export const getGetActivitiesFamilyCodeIdFamilyGroupQueryOptions = <
  TData = Awaited<ReturnType<typeof getActivitiesFamilyCodeIdFamilyGroup>>,
  TError = Error,
>(
  idFamilyGroup: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActivitiesFamilyCodeIdFamilyGroup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetActivitiesFamilyCodeIdFamilyGroupQueryKey(idFamilyGroup);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getActivitiesFamilyCodeIdFamilyGroup>>
  > = ({ signal }) =>
    getActivitiesFamilyCodeIdFamilyGroup(idFamilyGroup, {
      signal,
      ...requestOptions,
    });

  return {
    queryKey,
    queryFn,
    enabled: !!idFamilyGroup,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getActivitiesFamilyCodeIdFamilyGroup>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetActivitiesFamilyCodeIdFamilyGroupQueryResult = NonNullable<
  Awaited<ReturnType<typeof getActivitiesFamilyCodeIdFamilyGroup>>
>;
export type GetActivitiesFamilyCodeIdFamilyGroupQueryError = Error;

export function useGetActivitiesFamilyCodeIdFamilyGroup<
  TData = Awaited<ReturnType<typeof getActivitiesFamilyCodeIdFamilyGroup>>,
  TError = Error,
>(
  idFamilyGroup: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActivitiesFamilyCodeIdFamilyGroup>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActivitiesFamilyCodeIdFamilyGroup>>,
          TError,
          Awaited<ReturnType<typeof getActivitiesFamilyCodeIdFamilyGroup>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetActivitiesFamilyCodeIdFamilyGroup<
  TData = Awaited<ReturnType<typeof getActivitiesFamilyCodeIdFamilyGroup>>,
  TError = Error,
>(
  idFamilyGroup: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActivitiesFamilyCodeIdFamilyGroup>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActivitiesFamilyCodeIdFamilyGroup>>,
          TError,
          Awaited<ReturnType<typeof getActivitiesFamilyCodeIdFamilyGroup>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetActivitiesFamilyCodeIdFamilyGroup<
  TData = Awaited<ReturnType<typeof getActivitiesFamilyCodeIdFamilyGroup>>,
  TError = Error,
>(
  idFamilyGroup: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActivitiesFamilyCodeIdFamilyGroup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetActivitiesFamilyCodeIdFamilyGroup<
  TData = Awaited<ReturnType<typeof getActivitiesFamilyCodeIdFamilyGroup>>,
  TError = Error,
>(
  idFamilyGroup: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActivitiesFamilyCodeIdFamilyGroup>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetActivitiesFamilyCodeIdFamilyGroupQueryOptions(
    idFamilyGroup,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type postActivitiesResponse201 = {
  data: Activity;
  status: 201;
};

export type postActivitiesResponse400 = {
  data: Error;
  status: 400;
};

export type postActivitiesResponse500 = {
  data: Error;
  status: 500;
};

export type postActivitiesResponseSuccess = postActivitiesResponse201 & {
  headers: Headers;
};
export type postActivitiesResponseError = (
  | postActivitiesResponse400
  | postActivitiesResponse500
) & {
  headers: Headers;
};

export type postActivitiesResponse =
  | postActivitiesResponseSuccess
  | postActivitiesResponseError;

export const getPostActivitiesUrl = () => {
  return `/activities`;
};

export const postActivities = async (
  newActivity: NewActivity,
  options?: RequestInit,
): Promise<postActivitiesResponse> => {
  return rnFetch<postActivitiesResponse>(getPostActivitiesUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(newActivity),
  });
};

export const getPostActivitiesMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postActivities>>,
    TError,
    { data: NewActivity },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postActivities>>,
  TError,
  { data: NewActivity },
  TContext
> => {
  const mutationKey = ["postActivities"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postActivities>>,
    { data: NewActivity }
  > = (props) => {
    const { data } = props ?? {};

    return postActivities(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostActivitiesMutationResult = NonNullable<
  Awaited<ReturnType<typeof postActivities>>
>;
export type PostActivitiesMutationBody = NewActivity;
export type PostActivitiesMutationError = Error;

export const usePostActivities = <TError = Error, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postActivities>>,
      TError,
      { data: NewActivity },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postActivities>>,
  TError,
  { data: NewActivity },
  TContext
> => {
  const mutationOptions = getPostActivitiesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type postActivitiesGoogleCalendarEnableResponse200 = {
  data: PostActivitiesGoogleCalendarEnable200;
  status: 200;
};

export type postActivitiesGoogleCalendarEnableResponse400 = {
  data: Error;
  status: 400;
};

export type postActivitiesGoogleCalendarEnableResponse500 = {
  data: Error;
  status: 500;
};

export type postActivitiesGoogleCalendarEnableResponseSuccess =
  postActivitiesGoogleCalendarEnableResponse200 & {
    headers: Headers;
  };
export type postActivitiesGoogleCalendarEnableResponseError = (
  | postActivitiesGoogleCalendarEnableResponse400
  | postActivitiesGoogleCalendarEnableResponse500
) & {
  headers: Headers;
};

export type postActivitiesGoogleCalendarEnableResponse =
  | postActivitiesGoogleCalendarEnableResponseSuccess
  | postActivitiesGoogleCalendarEnableResponseError;

export const getPostActivitiesGoogleCalendarEnableUrl = () => {
  return `/activities/google-calendar/enable`;
};

export const postActivitiesGoogleCalendarEnable = async (
  postActivitiesGoogleCalendarEnableBody: PostActivitiesGoogleCalendarEnableBody,
  options?: RequestInit,
): Promise<postActivitiesGoogleCalendarEnableResponse> => {
  return rnFetch<postActivitiesGoogleCalendarEnableResponse>(
    getPostActivitiesGoogleCalendarEnableUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(postActivitiesGoogleCalendarEnableBody),
    },
  );
};

export const getPostActivitiesGoogleCalendarEnableMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postActivitiesGoogleCalendarEnable>>,
    TError,
    { data: PostActivitiesGoogleCalendarEnableBody },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postActivitiesGoogleCalendarEnable>>,
  TError,
  { data: PostActivitiesGoogleCalendarEnableBody },
  TContext
> => {
  const mutationKey = ["postActivitiesGoogleCalendarEnable"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postActivitiesGoogleCalendarEnable>>,
    { data: PostActivitiesGoogleCalendarEnableBody }
  > = (props) => {
    const { data } = props ?? {};

    return postActivitiesGoogleCalendarEnable(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostActivitiesGoogleCalendarEnableMutationResult = NonNullable<
  Awaited<ReturnType<typeof postActivitiesGoogleCalendarEnable>>
>;
export type PostActivitiesGoogleCalendarEnableMutationBody =
  PostActivitiesGoogleCalendarEnableBody;
export type PostActivitiesGoogleCalendarEnableMutationError = Error;

export const usePostActivitiesGoogleCalendarEnable = <
  TError = Error,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postActivitiesGoogleCalendarEnable>>,
      TError,
      { data: PostActivitiesGoogleCalendarEnableBody },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postActivitiesGoogleCalendarEnable>>,
  TError,
  { data: PostActivitiesGoogleCalendarEnableBody },
  TContext
> => {
  const mutationOptions =
    getPostActivitiesGoogleCalendarEnableMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type postActivitiesGoogleCalendarDisableResponse200 = {
  data: PostActivitiesGoogleCalendarDisable200;
  status: 200;
};

export type postActivitiesGoogleCalendarDisableResponse400 = {
  data: Error;
  status: 400;
};

export type postActivitiesGoogleCalendarDisableResponse500 = {
  data: Error;
  status: 500;
};

export type postActivitiesGoogleCalendarDisableResponseSuccess =
  postActivitiesGoogleCalendarDisableResponse200 & {
    headers: Headers;
  };
export type postActivitiesGoogleCalendarDisableResponseError = (
  | postActivitiesGoogleCalendarDisableResponse400
  | postActivitiesGoogleCalendarDisableResponse500
) & {
  headers: Headers;
};

export type postActivitiesGoogleCalendarDisableResponse =
  | postActivitiesGoogleCalendarDisableResponseSuccess
  | postActivitiesGoogleCalendarDisableResponseError;

export const getPostActivitiesGoogleCalendarDisableUrl = () => {
  return `/activities/google-calendar/disable`;
};

export const postActivitiesGoogleCalendarDisable = async (
  options?: RequestInit,
): Promise<postActivitiesGoogleCalendarDisableResponse> => {
  return rnFetch<postActivitiesGoogleCalendarDisableResponse>(
    getPostActivitiesGoogleCalendarDisableUrl(),
    {
      ...options,
      method: "POST",
    },
  );
};

export const getPostActivitiesGoogleCalendarDisableMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postActivitiesGoogleCalendarDisable>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postActivitiesGoogleCalendarDisable>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["postActivitiesGoogleCalendarDisable"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postActivitiesGoogleCalendarDisable>>,
    void
  > = () => {
    return postActivitiesGoogleCalendarDisable(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostActivitiesGoogleCalendarDisableMutationResult = NonNullable<
  Awaited<ReturnType<typeof postActivitiesGoogleCalendarDisable>>
>;

export type PostActivitiesGoogleCalendarDisableMutationError = Error;

export const usePostActivitiesGoogleCalendarDisable = <
  TError = Error,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postActivitiesGoogleCalendarDisable>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postActivitiesGoogleCalendarDisable>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions =
    getPostActivitiesGoogleCalendarDisableMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type getActivitiesGoogleCalendarStatusResponse200 = {
  data: GetActivitiesGoogleCalendarStatus200;
  status: 200;
};

export type getActivitiesGoogleCalendarStatusResponse500 = {
  data: Error;
  status: 500;
};

export type getActivitiesGoogleCalendarStatusResponseSuccess =
  getActivitiesGoogleCalendarStatusResponse200 & {
    headers: Headers;
  };
export type getActivitiesGoogleCalendarStatusResponseError =
  getActivitiesGoogleCalendarStatusResponse500 & {
    headers: Headers;
  };

export type getActivitiesGoogleCalendarStatusResponse =
  | getActivitiesGoogleCalendarStatusResponseSuccess
  | getActivitiesGoogleCalendarStatusResponseError;

export const getGetActivitiesGoogleCalendarStatusUrl = () => {
  return `/activities/google-calendar/status`;
};

export const getActivitiesGoogleCalendarStatus = async (
  options?: RequestInit,
): Promise<getActivitiesGoogleCalendarStatusResponse> => {
  return rnFetch<getActivitiesGoogleCalendarStatusResponse>(
    getGetActivitiesGoogleCalendarStatusUrl(),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetActivitiesGoogleCalendarStatusQueryKey = () => {
  return [`/activities/google-calendar/status`] as const;
};

export const getGetActivitiesGoogleCalendarStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof getActivitiesGoogleCalendarStatus>>,
  TError = Error,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getActivitiesGoogleCalendarStatus>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof rnFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetActivitiesGoogleCalendarStatusQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getActivitiesGoogleCalendarStatus>>
  > = ({ signal }) =>
    getActivitiesGoogleCalendarStatus({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getActivitiesGoogleCalendarStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetActivitiesGoogleCalendarStatusQueryResult = NonNullable<
  Awaited<ReturnType<typeof getActivitiesGoogleCalendarStatus>>
>;
export type GetActivitiesGoogleCalendarStatusQueryError = Error;

export function useGetActivitiesGoogleCalendarStatus<
  TData = Awaited<ReturnType<typeof getActivitiesGoogleCalendarStatus>>,
  TError = Error,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActivitiesGoogleCalendarStatus>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActivitiesGoogleCalendarStatus>>,
          TError,
          Awaited<ReturnType<typeof getActivitiesGoogleCalendarStatus>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetActivitiesGoogleCalendarStatus<
  TData = Awaited<ReturnType<typeof getActivitiesGoogleCalendarStatus>>,
  TError = Error,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActivitiesGoogleCalendarStatus>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActivitiesGoogleCalendarStatus>>,
          TError,
          Awaited<ReturnType<typeof getActivitiesGoogleCalendarStatus>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetActivitiesGoogleCalendarStatus<
  TData = Awaited<ReturnType<typeof getActivitiesGoogleCalendarStatus>>,
  TError = Error,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActivitiesGoogleCalendarStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetActivitiesGoogleCalendarStatus<
  TData = Awaited<ReturnType<typeof getActivitiesGoogleCalendarStatus>>,
  TError = Error,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActivitiesGoogleCalendarStatus>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions =
    getGetActivitiesGoogleCalendarStatusQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type getMemoriesResponse200 = {
  data: GetMemories200;
  status: 200;
};

export type getMemoriesResponse400 = {
  data: Error;
  status: 400;
};

export type getMemoriesResponse500 = {
  data: Error;
  status: 500;
};

export type getMemoriesResponseSuccess = getMemoriesResponse200 & {
  headers: Headers;
};
export type getMemoriesResponseError = (
  | getMemoriesResponse400
  | getMemoriesResponse500
) & {
  headers: Headers;
};

export type getMemoriesResponse =
  | getMemoriesResponseSuccess
  | getMemoriesResponseError;

export const getGetMemoriesUrl = (params?: GetMemoriesParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/memories?${stringifiedParams}`
    : `/memories`;
};

export const getMemories = async (
  params?: GetMemoriesParams,
  options?: RequestInit,
): Promise<getMemoriesResponse> => {
  return rnFetch<getMemoriesResponse>(getGetMemoriesUrl(params), {
    ...options,
    method: "GET",
  });
};

export const getGetMemoriesQueryKey = (params?: GetMemoriesParams) => {
  return [`/memories`, ...(params ? [params] : [])] as const;
};

export const getGetMemoriesQueryOptions = <
  TData = Awaited<ReturnType<typeof getMemories>>,
  TError = Error,
>(
  params?: GetMemoriesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMemories>>, TError, TData>
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMemoriesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMemories>>> = ({
    signal,
  }) => getMemories(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMemories>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMemoriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMemories>>
>;
export type GetMemoriesQueryError = Error;

export function useGetMemories<
  TData = Awaited<ReturnType<typeof getMemories>>,
  TError = Error,
>(
  params: undefined | GetMemoriesParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMemories>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMemories>>,
          TError,
          Awaited<ReturnType<typeof getMemories>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMemories<
  TData = Awaited<ReturnType<typeof getMemories>>,
  TError = Error,
>(
  params?: GetMemoriesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMemories>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMemories>>,
          TError,
          Awaited<ReturnType<typeof getMemories>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMemories<
  TData = Awaited<ReturnType<typeof getMemories>>,
  TError = Error,
>(
  params?: GetMemoriesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMemories>>, TError, TData>
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetMemories<
  TData = Awaited<ReturnType<typeof getMemories>>,
  TError = Error,
>(
  params?: GetMemoriesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMemories>>, TError, TData>
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetMemoriesQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type getMemoriesBooksResponse200 = {
  data: GetMemoriesBooks200;
  status: 200;
};

export type getMemoriesBooksResponse400 = {
  data: Error;
  status: 400;
};

export type getMemoriesBooksResponse401 = {
  data: Error;
  status: 401;
};

export type getMemoriesBooksResponse403 = {
  data: Error;
  status: 403;
};

export type getMemoriesBooksResponse500 = {
  data: Error;
  status: 500;
};

export type getMemoriesBooksResponseSuccess = getMemoriesBooksResponse200 & {
  headers: Headers;
};
export type getMemoriesBooksResponseError = (
  | getMemoriesBooksResponse400
  | getMemoriesBooksResponse401
  | getMemoriesBooksResponse403
  | getMemoriesBooksResponse500
) & {
  headers: Headers;
};

export type getMemoriesBooksResponse =
  | getMemoriesBooksResponseSuccess
  | getMemoriesBooksResponseError;

export const getGetMemoriesBooksUrl = (params: GetMemoriesBooksParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/memories/books?${stringifiedParams}`
    : `/memories/books`;
};

export const getMemoriesBooks = async (
  params: GetMemoriesBooksParams,
  options?: RequestInit,
): Promise<getMemoriesBooksResponse> => {
  return rnFetch<getMemoriesBooksResponse>(getGetMemoriesBooksUrl(params), {
    ...options,
    method: "GET",
  });
};

export const getGetMemoriesBooksQueryKey = (
  params?: GetMemoriesBooksParams,
) => {
  return [`/memories/books`, ...(params ? [params] : [])] as const;
};

export const getGetMemoriesBooksQueryOptions = <
  TData = Awaited<ReturnType<typeof getMemoriesBooks>>,
  TError = Error,
>(
  params: GetMemoriesBooksParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMemoriesBooks>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetMemoriesBooksQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getMemoriesBooks>>
  > = ({ signal }) => getMemoriesBooks(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getMemoriesBooks>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMemoriesBooksQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMemoriesBooks>>
>;
export type GetMemoriesBooksQueryError = Error;

export function useGetMemoriesBooks<
  TData = Awaited<ReturnType<typeof getMemoriesBooks>>,
  TError = Error,
>(
  params: GetMemoriesBooksParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMemoriesBooks>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMemoriesBooks>>,
          TError,
          Awaited<ReturnType<typeof getMemoriesBooks>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMemoriesBooks<
  TData = Awaited<ReturnType<typeof getMemoriesBooks>>,
  TError = Error,
>(
  params: GetMemoriesBooksParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMemoriesBooks>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMemoriesBooks>>,
          TError,
          Awaited<ReturnType<typeof getMemoriesBooks>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMemoriesBooks<
  TData = Awaited<ReturnType<typeof getMemoriesBooks>>,
  TError = Error,
>(
  params: GetMemoriesBooksParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMemoriesBooks>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetMemoriesBooks<
  TData = Awaited<ReturnType<typeof getMemoriesBooks>>,
  TError = Error,
>(
  params: GetMemoriesBooksParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMemoriesBooks>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetMemoriesBooksQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type createMemoriesBookResponse201 = {
  data: MemoriesBook;
  status: 201;
};

export type createMemoriesBookResponse400 = {
  data: Error;
  status: 400;
};

export type createMemoriesBookResponse401 = {
  data: Error;
  status: 401;
};

export type createMemoriesBookResponse403 = {
  data: Error;
  status: 403;
};

export type createMemoriesBookResponse500 = {
  data: Error;
  status: 500;
};

export type createMemoriesBookResponseSuccess =
  createMemoriesBookResponse201 & {
    headers: Headers;
  };
export type createMemoriesBookResponseError = (
  | createMemoriesBookResponse400
  | createMemoriesBookResponse401
  | createMemoriesBookResponse403
  | createMemoriesBookResponse500
) & {
  headers: Headers;
};

export type createMemoriesBookResponse =
  | createMemoriesBookResponseSuccess
  | createMemoriesBookResponseError;

export const getCreateMemoriesBookUrl = () => {
  return `/memories/books`;
};

export const createMemoriesBook = async (
  newMemoriesBook: NewMemoriesBook,
  options?: RequestInit,
): Promise<createMemoriesBookResponse> => {
  return rnFetch<createMemoriesBookResponse>(getCreateMemoriesBookUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(newMemoriesBook),
  });
};

export const getCreateMemoriesBookMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createMemoriesBook>>,
    TError,
    { data: NewMemoriesBook },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createMemoriesBook>>,
  TError,
  { data: NewMemoriesBook },
  TContext
> => {
  const mutationKey = ["createMemoriesBook"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createMemoriesBook>>,
    { data: NewMemoriesBook }
  > = (props) => {
    const { data } = props ?? {};

    return createMemoriesBook(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateMemoriesBookMutationResult = NonNullable<
  Awaited<ReturnType<typeof createMemoriesBook>>
>;
export type CreateMemoriesBookMutationBody = NewMemoriesBook;
export type CreateMemoriesBookMutationError = Error;

export const useCreateMemoriesBook = <TError = Error, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createMemoriesBook>>,
      TError,
      { data: NewMemoriesBook },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createMemoriesBook>>,
  TError,
  { data: NewMemoriesBook },
  TContext
> => {
  const mutationOptions = getCreateMemoriesBookMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type updateMemoriesBookResponse200 = {
  data: MemoriesBook;
  status: 200;
};

export type updateMemoriesBookResponse400 = {
  data: Error;
  status: 400;
};

export type updateMemoriesBookResponse401 = {
  data: Error;
  status: 401;
};

export type updateMemoriesBookResponse403 = {
  data: Error;
  status: 403;
};

export type updateMemoriesBookResponse404 = {
  data: Error;
  status: 404;
};

export type updateMemoriesBookResponse500 = {
  data: Error;
  status: 500;
};

export type updateMemoriesBookResponseSuccess =
  updateMemoriesBookResponse200 & {
    headers: Headers;
  };
export type updateMemoriesBookResponseError = (
  | updateMemoriesBookResponse400
  | updateMemoriesBookResponse401
  | updateMemoriesBookResponse403
  | updateMemoriesBookResponse404
  | updateMemoriesBookResponse500
) & {
  headers: Headers;
};

export type updateMemoriesBookResponse =
  | updateMemoriesBookResponseSuccess
  | updateMemoriesBookResponseError;

export const getUpdateMemoriesBookUrl = (id: string) => {
  return `/memories/books/${id}`;
};

export const updateMemoriesBook = async (
  id: string,
  updateMemoriesBook: UpdateMemoriesBook,
  options?: RequestInit,
): Promise<updateMemoriesBookResponse> => {
  return rnFetch<updateMemoriesBookResponse>(getUpdateMemoriesBookUrl(id), {
    ...options,
    method: "PATCH",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(updateMemoriesBook),
  });
};

export const getUpdateMemoriesBookMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateMemoriesBook>>,
    TError,
    { id: string; data: UpdateMemoriesBook },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateMemoriesBook>>,
  TError,
  { id: string; data: UpdateMemoriesBook },
  TContext
> => {
  const mutationKey = ["updateMemoriesBook"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateMemoriesBook>>,
    { id: string; data: UpdateMemoriesBook }
  > = (props) => {
    const { id, data } = props ?? {};

    return updateMemoriesBook(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateMemoriesBookMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateMemoriesBook>>
>;
export type UpdateMemoriesBookMutationBody = UpdateMemoriesBook;
export type UpdateMemoriesBookMutationError = Error;

export const useUpdateMemoriesBook = <TError = Error, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateMemoriesBook>>,
      TError,
      { id: string; data: UpdateMemoriesBook },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateMemoriesBook>>,
  TError,
  { id: string; data: UpdateMemoriesBook },
  TContext
> => {
  const mutationOptions = getUpdateMemoriesBookMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type deleteMemoriesBookResponse200 = {
  data: void;
  status: 200;
};

export type deleteMemoriesBookResponse400 = {
  data: Error;
  status: 400;
};

export type deleteMemoriesBookResponse401 = {
  data: Error;
  status: 401;
};

export type deleteMemoriesBookResponse403 = {
  data: Error;
  status: 403;
};

export type deleteMemoriesBookResponse404 = {
  data: Error;
  status: 404;
};

export type deleteMemoriesBookResponse500 = {
  data: Error;
  status: 500;
};

export type deleteMemoriesBookResponseSuccess =
  deleteMemoriesBookResponse200 & {
    headers: Headers;
  };
export type deleteMemoriesBookResponseError = (
  | deleteMemoriesBookResponse400
  | deleteMemoriesBookResponse401
  | deleteMemoriesBookResponse403
  | deleteMemoriesBookResponse404
  | deleteMemoriesBookResponse500
) & {
  headers: Headers;
};

export type deleteMemoriesBookResponse =
  | deleteMemoriesBookResponseSuccess
  | deleteMemoriesBookResponseError;

export const getDeleteMemoriesBookUrl = (id: string) => {
  return `/memories/books/${id}`;
};

export const deleteMemoriesBook = async (
  id: string,
  options?: RequestInit,
): Promise<deleteMemoriesBookResponse> => {
  return rnFetch<deleteMemoriesBookResponse>(getDeleteMemoriesBookUrl(id), {
    ...options,
    method: "DELETE",
  });
};

export const getDeleteMemoriesBookMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteMemoriesBook>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteMemoriesBook>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ["deleteMemoriesBook"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteMemoriesBook>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return deleteMemoriesBook(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteMemoriesBookMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteMemoriesBook>>
>;

export type DeleteMemoriesBookMutationError = Error;

export const useDeleteMemoriesBook = <TError = Error, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteMemoriesBook>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteMemoriesBook>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteMemoriesBookMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type getMemoriesIdResponse200 = {
  data: Memory;
  status: 200;
};

export type getMemoriesIdResponse400 = {
  data: Error;
  status: 400;
};

export type getMemoriesIdResponse404 = {
  data: Error;
  status: 404;
};

export type getMemoriesIdResponse500 = {
  data: Error;
  status: 500;
};

export type getMemoriesIdResponseSuccess = getMemoriesIdResponse200 & {
  headers: Headers;
};
export type getMemoriesIdResponseError = (
  | getMemoriesIdResponse400
  | getMemoriesIdResponse404
  | getMemoriesIdResponse500
) & {
  headers: Headers;
};

export type getMemoriesIdResponse =
  | getMemoriesIdResponseSuccess
  | getMemoriesIdResponseError;

export const getGetMemoriesIdUrl = (id: string) => {
  return `/memories/${id}`;
};

export const getMemoriesId = async (
  id: string,
  options?: RequestInit,
): Promise<getMemoriesIdResponse> => {
  return rnFetch<getMemoriesIdResponse>(getGetMemoriesIdUrl(id), {
    ...options,
    method: "GET",
  });
};

export const getGetMemoriesIdQueryKey = (id?: string) => {
  return [`/memories/${id}`] as const;
};

export const getGetMemoriesIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getMemoriesId>>,
  TError = Error,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMemoriesId>>, TError, TData>
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetMemoriesIdQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMemoriesId>>> = ({
    signal,
  }) => getMemoriesId(id, { signal, ...requestOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getMemoriesId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetMemoriesIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMemoriesId>>
>;
export type GetMemoriesIdQueryError = Error;

export function useGetMemoriesId<
  TData = Awaited<ReturnType<typeof getMemoriesId>>,
  TError = Error,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMemoriesId>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMemoriesId>>,
          TError,
          Awaited<ReturnType<typeof getMemoriesId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMemoriesId<
  TData = Awaited<ReturnType<typeof getMemoriesId>>,
  TError = Error,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMemoriesId>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getMemoriesId>>,
          TError,
          Awaited<ReturnType<typeof getMemoriesId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetMemoriesId<
  TData = Awaited<ReturnType<typeof getMemoriesId>>,
  TError = Error,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMemoriesId>>, TError, TData>
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetMemoriesId<
  TData = Awaited<ReturnType<typeof getMemoriesId>>,
  TError = Error,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getMemoriesId>>, TError, TData>
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetMemoriesIdQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type updateMemoryResponse200 = {
  data: Memory;
  status: 200;
};

export type updateMemoryResponse400 = {
  data: Error;
  status: 400;
};

export type updateMemoryResponse401 = {
  data: Error;
  status: 401;
};

export type updateMemoryResponse403 = {
  data: Error;
  status: 403;
};

export type updateMemoryResponse404 = {
  data: Error;
  status: 404;
};

export type updateMemoryResponse500 = {
  data: Error;
  status: 500;
};

export type updateMemoryResponseSuccess = updateMemoryResponse200 & {
  headers: Headers;
};
export type updateMemoryResponseError = (
  | updateMemoryResponse400
  | updateMemoryResponse401
  | updateMemoryResponse403
  | updateMemoryResponse404
  | updateMemoryResponse500
) & {
  headers: Headers;
};

export type updateMemoryResponse =
  | updateMemoryResponseSuccess
  | updateMemoryResponseError;

export const getUpdateMemoryUrl = (id: string) => {
  return `/memories/${id}`;
};

export const updateMemory = async (
  id: string,
  updateMemory: UpdateMemory,
  options?: RequestInit,
): Promise<updateMemoryResponse> => {
  return rnFetch<updateMemoryResponse>(getUpdateMemoryUrl(id), {
    ...options,
    method: "PATCH",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(updateMemory),
  });
};

export const getUpdateMemoryMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateMemory>>,
    TError,
    { id: string; data: UpdateMemory },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateMemory>>,
  TError,
  { id: string; data: UpdateMemory },
  TContext
> => {
  const mutationKey = ["updateMemory"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateMemory>>,
    { id: string; data: UpdateMemory }
  > = (props) => {
    const { id, data } = props ?? {};

    return updateMemory(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateMemoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateMemory>>
>;
export type UpdateMemoryMutationBody = UpdateMemory;
export type UpdateMemoryMutationError = Error;

export const useUpdateMemory = <TError = Error, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateMemory>>,
      TError,
      { id: string; data: UpdateMemory },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateMemory>>,
  TError,
  { id: string; data: UpdateMemory },
  TContext
> => {
  const mutationOptions = getUpdateMemoryMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type deleteMemoryResponse200 = {
  data: void;
  status: 200;
};

export type deleteMemoryResponse400 = {
  data: Error;
  status: 400;
};

export type deleteMemoryResponse401 = {
  data: Error;
  status: 401;
};

export type deleteMemoryResponse403 = {
  data: Error;
  status: 403;
};

export type deleteMemoryResponse404 = {
  data: Error;
  status: 404;
};

export type deleteMemoryResponse500 = {
  data: Error;
  status: 500;
};

export type deleteMemoryResponseSuccess = deleteMemoryResponse200 & {
  headers: Headers;
};
export type deleteMemoryResponseError = (
  | deleteMemoryResponse400
  | deleteMemoryResponse401
  | deleteMemoryResponse403
  | deleteMemoryResponse404
  | deleteMemoryResponse500
) & {
  headers: Headers;
};

export type deleteMemoryResponse =
  | deleteMemoryResponseSuccess
  | deleteMemoryResponseError;

export const getDeleteMemoryUrl = (id: string) => {
  return `/memories/${id}`;
};

export const deleteMemory = async (
  id: string,
  options?: RequestInit,
): Promise<deleteMemoryResponse> => {
  return rnFetch<deleteMemoryResponse>(getDeleteMemoryUrl(id), {
    ...options,
    method: "DELETE",
  });
};

export const getDeleteMemoryMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteMemory>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteMemory>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ["deleteMemory"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteMemory>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return deleteMemory(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteMemoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteMemory>>
>;

export type DeleteMemoryMutationError = Error;

export const useDeleteMemory = <TError = Error, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteMemory>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteMemory>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteMemoryMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type createMemoryWithMediaResponse201 = {
  data: Memory;
  status: 201;
};

export type createMemoryWithMediaResponse400 = {
  data: Error;
  status: 400;
};

export type createMemoryWithMediaResponse401 = {
  data: Error;
  status: 401;
};

export type createMemoryWithMediaResponse413 = {
  data: Error;
  status: 413;
};

export type createMemoryWithMediaResponse415 = {
  data: Error;
  status: 415;
};

export type createMemoryWithMediaResponse500 = {
  data: Error;
  status: 500;
};

export type createMemoryWithMediaResponseSuccess =
  createMemoryWithMediaResponse201 & {
    headers: Headers;
  };
export type createMemoryWithMediaResponseError = (
  | createMemoryWithMediaResponse400
  | createMemoryWithMediaResponse401
  | createMemoryWithMediaResponse413
  | createMemoryWithMediaResponse415
  | createMemoryWithMediaResponse500
) & {
  headers: Headers;
};

export type createMemoryWithMediaResponse =
  | createMemoryWithMediaResponseSuccess
  | createMemoryWithMediaResponseError;

export const getCreateMemoryWithMediaUrl = () => {
  return `/memories/upload`;
};

export const createMemoryWithMedia = async (
  createMemoryWithMediaBody: CreateMemoryWithMediaBody,
  options?: RequestInit,
): Promise<createMemoryWithMediaResponse> => {
  const formData = new FormData();
  formData.append(`bookId`, createMemoryWithMediaBody.bookId);
  formData.append(`groupId`, createMemoryWithMediaBody.groupId);
  if (createMemoryWithMediaBody.title !== undefined) {
    formData.append(`title`, createMemoryWithMediaBody.title);
  }
  if (createMemoryWithMediaBody.caption !== undefined) {
    formData.append(`caption`, createMemoryWithMediaBody.caption);
  }
  formData.append(`image`, createMemoryWithMediaBody.image);

  return rnFetch<createMemoryWithMediaResponse>(getCreateMemoryWithMediaUrl(), {
    ...options,
    method: "POST",
    body: formData,
  });
};

export const getCreateMemoryWithMediaMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createMemoryWithMedia>>,
    TError,
    { data: CreateMemoryWithMediaBody },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createMemoryWithMedia>>,
  TError,
  { data: CreateMemoryWithMediaBody },
  TContext
> => {
  const mutationKey = ["createMemoryWithMedia"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createMemoryWithMedia>>,
    { data: CreateMemoryWithMediaBody }
  > = (props) => {
    const { data } = props ?? {};

    return createMemoryWithMedia(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateMemoryWithMediaMutationResult = NonNullable<
  Awaited<ReturnType<typeof createMemoryWithMedia>>
>;
export type CreateMemoryWithMediaMutationBody = CreateMemoryWithMediaBody;
export type CreateMemoryWithMediaMutationError = Error;

export const useCreateMemoryWithMedia = <TError = Error, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createMemoryWithMedia>>,
      TError,
      { data: CreateMemoryWithMediaBody },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createMemoryWithMedia>>,
  TError,
  { data: CreateMemoryWithMediaBody },
  TContext
> => {
  const mutationOptions = getCreateMemoryWithMediaMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type createNoteResponse201 = {
  data: Memory;
  status: 201;
};

export type createNoteResponse400 = {
  data: Error;
  status: 400;
};

export type createNoteResponse401 = {
  data: Error;
  status: 401;
};

export type createNoteResponse500 = {
  data: Error;
  status: 500;
};

export type createNoteResponseSuccess = createNoteResponse201 & {
  headers: Headers;
};
export type createNoteResponseError = (
  | createNoteResponse400
  | createNoteResponse401
  | createNoteResponse500
) & {
  headers: Headers;
};

export type createNoteResponse =
  | createNoteResponseSuccess
  | createNoteResponseError;

export const getCreateNoteUrl = () => {
  return `/memories/note`;
};

export const createNote = async (
  createNote: CreateNote,
  options?: RequestInit,
): Promise<createNoteResponse> => {
  return rnFetch<createNoteResponse>(getCreateNoteUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(createNote),
  });
};

export const getCreateNoteMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createNote>>,
    TError,
    { data: CreateNote },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createNote>>,
  TError,
  { data: CreateNote },
  TContext
> => {
  const mutationKey = ["createNote"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createNote>>,
    { data: CreateNote }
  > = (props) => {
    const { data } = props ?? {};

    return createNote(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateNoteMutationResult = NonNullable<
  Awaited<ReturnType<typeof createNote>>
>;
export type CreateNoteMutationBody = CreateNote;
export type CreateNoteMutationError = Error;

export const useCreateNote = <TError = Error, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createNote>>,
      TError,
      { data: CreateNote },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createNote>>,
  TError,
  { data: CreateNote },
  TContext
> => {
  const mutationOptions = getCreateNoteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type postAlbumTranscribeResponse200 = {
  data: Transcription;
  status: 200;
};

export type postAlbumTranscribeResponse400 = {
  data: Error;
  status: 400;
};

export type postAlbumTranscribeResponse401 = {
  data: Error;
  status: 401;
};

export type postAlbumTranscribeResponse415 = {
  data: Error;
  status: 415;
};

export type postAlbumTranscribeResponse500 = {
  data: Error;
  status: 500;
};

export type postAlbumTranscribeResponseSuccess =
  postAlbumTranscribeResponse200 & {
    headers: Headers;
  };
export type postAlbumTranscribeResponseError = (
  | postAlbumTranscribeResponse400
  | postAlbumTranscribeResponse401
  | postAlbumTranscribeResponse415
  | postAlbumTranscribeResponse500
) & {
  headers: Headers;
};

export type postAlbumTranscribeResponse =
  | postAlbumTranscribeResponseSuccess
  | postAlbumTranscribeResponseError;

export const getPostAlbumTranscribeUrl = () => {
  return `/album/transcribe`;
};

export const postAlbumTranscribe = async (
  postAlbumTranscribeBody: PostAlbumTranscribeBody,
  options?: RequestInit,
): Promise<postAlbumTranscribeResponse> => {
  const formData = new FormData();
  formData.append(`audio`, postAlbumTranscribeBody.audio);

  return rnFetch<postAlbumTranscribeResponse>(getPostAlbumTranscribeUrl(), {
    ...options,
    method: "POST",
    body: formData,
  });
};

export const getPostAlbumTranscribeMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAlbumTranscribe>>,
    TError,
    { data: PostAlbumTranscribeBody },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAlbumTranscribe>>,
  TError,
  { data: PostAlbumTranscribeBody },
  TContext
> => {
  const mutationKey = ["postAlbumTranscribe"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAlbumTranscribe>>,
    { data: PostAlbumTranscribeBody }
  > = (props) => {
    const { data } = props ?? {};

    return postAlbumTranscribe(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAlbumTranscribeMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAlbumTranscribe>>
>;
export type PostAlbumTranscribeMutationBody = PostAlbumTranscribeBody;
export type PostAlbumTranscribeMutationError = Error;

export const usePostAlbumTranscribe = <TError = Error, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAlbumTranscribe>>,
      TError,
      { data: PostAlbumTranscribeBody },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAlbumTranscribe>>,
  TError,
  { data: PostAlbumTranscribeBody },
  TContext
> => {
  const mutationOptions = getPostAlbumTranscribeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type postAlbumCreateResponse201 = {
  data: AlbumWithPages;
  status: 201;
};

export type postAlbumCreateResponse400 = {
  data: Error;
  status: 400;
};

export type postAlbumCreateResponse401 = {
  data: Error;
  status: 401;
};

export type postAlbumCreateResponse500 = {
  data: Error;
  status: 500;
};

export type postAlbumCreateResponseSuccess = postAlbumCreateResponse201 & {
  headers: Headers;
};
export type postAlbumCreateResponseError = (
  | postAlbumCreateResponse400
  | postAlbumCreateResponse401
  | postAlbumCreateResponse500
) & {
  headers: Headers;
};

export type postAlbumCreateResponse =
  | postAlbumCreateResponseSuccess
  | postAlbumCreateResponseError;

export const getPostAlbumCreateUrl = () => {
  return `/album/create`;
};

export const postAlbumCreate = async (
  createAlbumRequest: CreateAlbumRequest,
  options?: RequestInit,
): Promise<postAlbumCreateResponse> => {
  return rnFetch<postAlbumCreateResponse>(getPostAlbumCreateUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(createAlbumRequest),
  });
};

export const getPostAlbumCreateMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAlbumCreate>>,
    TError,
    { data: CreateAlbumRequest },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAlbumCreate>>,
  TError,
  { data: CreateAlbumRequest },
  TContext
> => {
  const mutationKey = ["postAlbumCreate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAlbumCreate>>,
    { data: CreateAlbumRequest }
  > = (props) => {
    const { data } = props ?? {};

    return postAlbumCreate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAlbumCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAlbumCreate>>
>;
export type PostAlbumCreateMutationBody = CreateAlbumRequest;
export type PostAlbumCreateMutationError = Error;

export const usePostAlbumCreate = <TError = Error, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAlbumCreate>>,
      TError,
      { data: CreateAlbumRequest },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAlbumCreate>>,
  TError,
  { data: CreateAlbumRequest },
  TContext
> => {
  const mutationOptions = getPostAlbumCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type getAlbumResponse200 = {
  data: Album[];
  status: 200;
};

export type getAlbumResponse401 = {
  data: Error;
  status: 401;
};

export type getAlbumResponse500 = {
  data: Error;
  status: 500;
};

export type getAlbumResponseSuccess = getAlbumResponse200 & {
  headers: Headers;
};
export type getAlbumResponseError = (
  | getAlbumResponse401
  | getAlbumResponse500
) & {
  headers: Headers;
};

export type getAlbumResponse = getAlbumResponseSuccess | getAlbumResponseError;

export const getGetAlbumUrl = (params?: GetAlbumParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/album?${stringifiedParams}`
    : `/album`;
};

export const getAlbum = async (
  params?: GetAlbumParams,
  options?: RequestInit,
): Promise<getAlbumResponse> => {
  return rnFetch<getAlbumResponse>(getGetAlbumUrl(params), {
    ...options,
    method: "GET",
  });
};

export const getGetAlbumQueryKey = (params?: GetAlbumParams) => {
  return [`/album`, ...(params ? [params] : [])] as const;
};

export const getGetAlbumQueryOptions = <
  TData = Awaited<ReturnType<typeof getAlbum>>,
  TError = Error,
>(
  params?: GetAlbumParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAlbum>>, TError, TData>
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAlbumQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAlbum>>> = ({
    signal,
  }) => getAlbum(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAlbum>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAlbumQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAlbum>>
>;
export type GetAlbumQueryError = Error;

export function useGetAlbum<
  TData = Awaited<ReturnType<typeof getAlbum>>,
  TError = Error,
>(
  params: undefined | GetAlbumParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAlbum>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAlbum>>,
          TError,
          Awaited<ReturnType<typeof getAlbum>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAlbum<
  TData = Awaited<ReturnType<typeof getAlbum>>,
  TError = Error,
>(
  params?: GetAlbumParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAlbum>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAlbum>>,
          TError,
          Awaited<ReturnType<typeof getAlbum>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAlbum<
  TData = Awaited<ReturnType<typeof getAlbum>>,
  TError = Error,
>(
  params?: GetAlbumParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAlbum>>, TError, TData>
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetAlbum<
  TData = Awaited<ReturnType<typeof getAlbum>>,
  TError = Error,
>(
  params?: GetAlbumParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAlbum>>, TError, TData>
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAlbumQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type getAlbumIdResponse200 = {
  data: AlbumWithPages;
  status: 200;
};

export type getAlbumIdResponse401 = {
  data: Error;
  status: 401;
};

export type getAlbumIdResponse404 = {
  data: Error;
  status: 404;
};

export type getAlbumIdResponse500 = {
  data: Error;
  status: 500;
};

export type getAlbumIdResponseSuccess = getAlbumIdResponse200 & {
  headers: Headers;
};
export type getAlbumIdResponseError = (
  | getAlbumIdResponse401
  | getAlbumIdResponse404
  | getAlbumIdResponse500
) & {
  headers: Headers;
};

export type getAlbumIdResponse =
  | getAlbumIdResponseSuccess
  | getAlbumIdResponseError;

export const getGetAlbumIdUrl = (id: string) => {
  return `/album/${id}`;
};

export const getAlbumId = async (
  id: string,
  options?: RequestInit,
): Promise<getAlbumIdResponse> => {
  return rnFetch<getAlbumIdResponse>(getGetAlbumIdUrl(id), {
    ...options,
    method: "GET",
  });
};

export const getGetAlbumIdQueryKey = (id?: string) => {
  return [`/album/${id}`] as const;
};

export const getGetAlbumIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getAlbumId>>,
  TError = Error,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAlbumId>>, TError, TData>
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAlbumIdQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAlbumId>>> = ({
    signal,
  }) => getAlbumId(id, { signal, ...requestOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAlbumId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAlbumIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAlbumId>>
>;
export type GetAlbumIdQueryError = Error;

export function useGetAlbumId<
  TData = Awaited<ReturnType<typeof getAlbumId>>,
  TError = Error,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAlbumId>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAlbumId>>,
          TError,
          Awaited<ReturnType<typeof getAlbumId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAlbumId<
  TData = Awaited<ReturnType<typeof getAlbumId>>,
  TError = Error,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAlbumId>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAlbumId>>,
          TError,
          Awaited<ReturnType<typeof getAlbumId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAlbumId<
  TData = Awaited<ReturnType<typeof getAlbumId>>,
  TError = Error,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAlbumId>>, TError, TData>
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetAlbumId<
  TData = Awaited<ReturnType<typeof getAlbumId>>,
  TError = Error,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAlbumId>>, TError, TData>
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAlbumIdQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type getFrequenciesResponse200 = {
  data: Frequency[];
  status: 200;
};

export type getFrequenciesResponse500 = {
  data: Error;
  status: 500;
};

export type getFrequenciesResponseSuccess = getFrequenciesResponse200 & {
  headers: Headers;
};
export type getFrequenciesResponseError = getFrequenciesResponse500 & {
  headers: Headers;
};

export type getFrequenciesResponse =
  | getFrequenciesResponseSuccess
  | getFrequenciesResponseError;

export const getGetFrequenciesUrl = () => {
  return `/frequencies`;
};

export const getFrequencies = async (
  options?: RequestInit,
): Promise<getFrequenciesResponse> => {
  return rnFetch<getFrequenciesResponse>(getGetFrequenciesUrl(), {
    ...options,
    method: "GET",
  });
};

export const getGetFrequenciesQueryKey = () => {
  return [`/frequencies`] as const;
};

export const getGetFrequenciesQueryOptions = <
  TData = Awaited<ReturnType<typeof getFrequencies>>,
  TError = Error,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getFrequencies>>, TError, TData>
  >;
  request?: SecondParameter<typeof rnFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFrequenciesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getFrequencies>>> = ({
    signal,
  }) => getFrequencies({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getFrequencies>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetFrequenciesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFrequencies>>
>;
export type GetFrequenciesQueryError = Error;

export function useGetFrequencies<
  TData = Awaited<ReturnType<typeof getFrequencies>>,
  TError = Error,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFrequencies>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFrequencies>>,
          TError,
          Awaited<ReturnType<typeof getFrequencies>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFrequencies<
  TData = Awaited<ReturnType<typeof getFrequencies>>,
  TError = Error,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFrequencies>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFrequencies>>,
          TError,
          Awaited<ReturnType<typeof getFrequencies>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFrequencies<
  TData = Awaited<ReturnType<typeof getFrequencies>>,
  TError = Error,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFrequencies>>, TError, TData>
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetFrequencies<
  TData = Awaited<ReturnType<typeof getFrequencies>>,
  TError = Error,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getFrequencies>>, TError, TData>
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetFrequenciesQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type postFrequenciesResponse201 = {
  data: Frequency;
  status: 201;
};

export type postFrequenciesResponse400 = {
  data: Error;
  status: 400;
};

export type postFrequenciesResponse500 = {
  data: Error;
  status: 500;
};

export type postFrequenciesResponseSuccess = postFrequenciesResponse201 & {
  headers: Headers;
};
export type postFrequenciesResponseError = (
  | postFrequenciesResponse400
  | postFrequenciesResponse500
) & {
  headers: Headers;
};

export type postFrequenciesResponse =
  | postFrequenciesResponseSuccess
  | postFrequenciesResponseError;

export const getPostFrequenciesUrl = () => {
  return `/frequencies`;
};

export const postFrequencies = async (
  newFrequency: NewFrequency,
  options?: RequestInit,
): Promise<postFrequenciesResponse> => {
  return rnFetch<postFrequenciesResponse>(getPostFrequenciesUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(newFrequency),
  });
};

export const getPostFrequenciesMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postFrequencies>>,
    TError,
    { data: NewFrequency },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postFrequencies>>,
  TError,
  { data: NewFrequency },
  TContext
> => {
  const mutationKey = ["postFrequencies"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postFrequencies>>,
    { data: NewFrequency }
  > = (props) => {
    const { data } = props ?? {};

    return postFrequencies(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostFrequenciesMutationResult = NonNullable<
  Awaited<ReturnType<typeof postFrequencies>>
>;
export type PostFrequenciesMutationBody = NewFrequency;
export type PostFrequenciesMutationError = Error;

export const usePostFrequencies = <TError = Error, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postFrequencies>>,
      TError,
      { data: NewFrequency },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postFrequencies>>,
  TError,
  { data: NewFrequency },
  TContext
> => {
  const mutationOptions = getPostFrequenciesMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type getFrequenciesIdResponse200 = {
  data: Frequency;
  status: 200;
};

export type getFrequenciesIdResponse404 = {
  data: Error;
  status: 404;
};

export type getFrequenciesIdResponse500 = {
  data: Error;
  status: 500;
};

export type getFrequenciesIdResponseSuccess = getFrequenciesIdResponse200 & {
  headers: Headers;
};
export type getFrequenciesIdResponseError = (
  | getFrequenciesIdResponse404
  | getFrequenciesIdResponse500
) & {
  headers: Headers;
};

export type getFrequenciesIdResponse =
  | getFrequenciesIdResponseSuccess
  | getFrequenciesIdResponseError;

export const getGetFrequenciesIdUrl = (id: string) => {
  return `/frequencies/${id}`;
};

export const getFrequenciesId = async (
  id: string,
  options?: RequestInit,
): Promise<getFrequenciesIdResponse> => {
  return rnFetch<getFrequenciesIdResponse>(getGetFrequenciesIdUrl(id), {
    ...options,
    method: "GET",
  });
};

export const getGetFrequenciesIdQueryKey = (id?: string) => {
  return [`/frequencies/${id}`] as const;
};

export const getGetFrequenciesIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getFrequenciesId>>,
  TError = Error,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFrequenciesId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetFrequenciesIdQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getFrequenciesId>>
  > = ({ signal }) => getFrequenciesId(id, { signal, ...requestOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getFrequenciesId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetFrequenciesIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getFrequenciesId>>
>;
export type GetFrequenciesIdQueryError = Error;

export function useGetFrequenciesId<
  TData = Awaited<ReturnType<typeof getFrequenciesId>>,
  TError = Error,
>(
  id: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFrequenciesId>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFrequenciesId>>,
          TError,
          Awaited<ReturnType<typeof getFrequenciesId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFrequenciesId<
  TData = Awaited<ReturnType<typeof getFrequenciesId>>,
  TError = Error,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFrequenciesId>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getFrequenciesId>>,
          TError,
          Awaited<ReturnType<typeof getFrequenciesId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetFrequenciesId<
  TData = Awaited<ReturnType<typeof getFrequenciesId>>,
  TError = Error,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFrequenciesId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetFrequenciesId<
  TData = Awaited<ReturnType<typeof getFrequenciesId>>,
  TError = Error,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getFrequenciesId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetFrequenciesIdQueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Obtener completaciones del usuario
 */
export type getActivityCompletionsResponse200 = {
  data: GetActivityCompletions200;
  status: 200;
};

export type getActivityCompletionsResponse500 = {
  data: GetActivityCompletions500;
  status: 500;
};

export type getActivityCompletionsResponseSuccess =
  getActivityCompletionsResponse200 & {
    headers: Headers;
  };
export type getActivityCompletionsResponseError =
  getActivityCompletionsResponse500 & {
    headers: Headers;
  };

export type getActivityCompletionsResponse =
  | getActivityCompletionsResponseSuccess
  | getActivityCompletionsResponseError;

export const getGetActivityCompletionsUrl = (
  params?: GetActivityCompletionsParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/activity-completions?${stringifiedParams}`
    : `/activity-completions`;
};

export const getActivityCompletions = async (
  params?: GetActivityCompletionsParams,
  options?: RequestInit,
): Promise<getActivityCompletionsResponse> => {
  return rnFetch<getActivityCompletionsResponse>(
    getGetActivityCompletionsUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetActivityCompletionsQueryKey = (
  params?: GetActivityCompletionsParams,
) => {
  return [`/activity-completions`, ...(params ? [params] : [])] as const;
};

export const getGetActivityCompletionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getActivityCompletions>>,
  TError = GetActivityCompletions500,
>(
  params?: GetActivityCompletionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActivityCompletions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetActivityCompletionsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getActivityCompletions>>
  > = ({ signal }) =>
    getActivityCompletions(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getActivityCompletions>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetActivityCompletionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getActivityCompletions>>
>;
export type GetActivityCompletionsQueryError = GetActivityCompletions500;

export function useGetActivityCompletions<
  TData = Awaited<ReturnType<typeof getActivityCompletions>>,
  TError = GetActivityCompletions500,
>(
  params: undefined | GetActivityCompletionsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActivityCompletions>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActivityCompletions>>,
          TError,
          Awaited<ReturnType<typeof getActivityCompletions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetActivityCompletions<
  TData = Awaited<ReturnType<typeof getActivityCompletions>>,
  TError = GetActivityCompletions500,
>(
  params?: GetActivityCompletionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActivityCompletions>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getActivityCompletions>>,
          TError,
          Awaited<ReturnType<typeof getActivityCompletions>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetActivityCompletions<
  TData = Awaited<ReturnType<typeof getActivityCompletions>>,
  TError = GetActivityCompletions500,
>(
  params?: GetActivityCompletionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActivityCompletions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Obtener completaciones del usuario
 */

export function useGetActivityCompletions<
  TData = Awaited<ReturnType<typeof getActivityCompletions>>,
  TError = GetActivityCompletions500,
>(
  params?: GetActivityCompletionsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getActivityCompletions>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetActivityCompletionsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Toggle completaci√≥n de actividad para un d√≠a
 */
export type postActivityCompletionsToggleResponse200 = {
  data: PostActivityCompletionsToggle200;
  status: 200;
};

export type postActivityCompletionsToggleResponse500 = {
  data: PostActivityCompletionsToggle500;
  status: 500;
};

export type postActivityCompletionsToggleResponseSuccess =
  postActivityCompletionsToggleResponse200 & {
    headers: Headers;
  };
export type postActivityCompletionsToggleResponseError =
  postActivityCompletionsToggleResponse500 & {
    headers: Headers;
  };

export type postActivityCompletionsToggleResponse =
  | postActivityCompletionsToggleResponseSuccess
  | postActivityCompletionsToggleResponseError;

export const getPostActivityCompletionsToggleUrl = () => {
  return `/activity-completions/toggle`;
};

export const postActivityCompletionsToggle = async (
  postActivityCompletionsToggleBody: PostActivityCompletionsToggleBody,
  options?: RequestInit,
): Promise<postActivityCompletionsToggleResponse> => {
  return rnFetch<postActivityCompletionsToggleResponse>(
    getPostActivityCompletionsToggleUrl(),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(postActivityCompletionsToggleBody),
    },
  );
};

export const getPostActivityCompletionsToggleMutationOptions = <
  TError = PostActivityCompletionsToggle500,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postActivityCompletionsToggle>>,
    TError,
    { data: PostActivityCompletionsToggleBody },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postActivityCompletionsToggle>>,
  TError,
  { data: PostActivityCompletionsToggleBody },
  TContext
> => {
  const mutationKey = ["postActivityCompletionsToggle"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postActivityCompletionsToggle>>,
    { data: PostActivityCompletionsToggleBody }
  > = (props) => {
    const { data } = props ?? {};

    return postActivityCompletionsToggle(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostActivityCompletionsToggleMutationResult = NonNullable<
  Awaited<ReturnType<typeof postActivityCompletionsToggle>>
>;
export type PostActivityCompletionsToggleMutationBody =
  PostActivityCompletionsToggleBody;
export type PostActivityCompletionsToggleMutationError =
  PostActivityCompletionsToggle500;

/**
 * @summary Toggle completaci√≥n de actividad para un d√≠a
 */
export const usePostActivityCompletionsToggle = <
  TError = PostActivityCompletionsToggle500,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postActivityCompletionsToggle>>,
      TError,
      { data: PostActivityCompletionsToggleBody },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postActivityCompletionsToggle>>,
  TError,
  { data: PostActivityCompletionsToggleBody },
  TContext
> => {
  const mutationOptions =
    getPostActivityCompletionsToggleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type getGamesResponse200 = {
  data: GameListItem[];
  status: 200;
};

export type getGamesResponse500 = {
  data: Error;
  status: 500;
};

export type getGamesResponseSuccess = getGamesResponse200 & {
  headers: Headers;
};
export type getGamesResponseError = getGamesResponse500 & {
  headers: Headers;
};

export type getGamesResponse = getGamesResponseSuccess | getGamesResponseError;

export const getGetGamesUrl = () => {
  return `/games`;
};

export const getGames = async (
  options?: RequestInit,
): Promise<getGamesResponse> => {
  return rnFetch<getGamesResponse>(getGetGamesUrl(), {
    ...options,
    method: "GET",
  });
};

export const getGetGamesQueryKey = () => {
  return [`/games`] as const;
};

export const getGetGamesQueryOptions = <
  TData = Awaited<ReturnType<typeof getGames>>,
  TError = Error,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getGames>>, TError, TData>
  >;
  request?: SecondParameter<typeof rnFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetGamesQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGames>>> = ({
    signal,
  }) => getGames({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getGames>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetGamesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGames>>
>;
export type GetGamesQueryError = Error;

export function useGetGames<
  TData = Awaited<ReturnType<typeof getGames>>,
  TError = Error,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGames>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGames>>,
          TError,
          Awaited<ReturnType<typeof getGames>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGames<
  TData = Awaited<ReturnType<typeof getGames>>,
  TError = Error,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGames>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGames>>,
          TError,
          Awaited<ReturnType<typeof getGames>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGames<
  TData = Awaited<ReturnType<typeof getGames>>,
  TError = Error,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGames>>, TError, TData>
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetGames<
  TData = Awaited<ReturnType<typeof getGames>>,
  TError = Error,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGames>>, TError, TData>
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetGamesQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type getGamesGameNameResponse200 = {
  data: GameListItem;
  status: 200;
};

export type getGamesGameNameResponse404 = {
  data: Error;
  status: 404;
};

export type getGamesGameNameResponse500 = {
  data: Error;
  status: 500;
};

export type getGamesGameNameResponseSuccess = getGamesGameNameResponse200 & {
  headers: Headers;
};
export type getGamesGameNameResponseError = (
  | getGamesGameNameResponse404
  | getGamesGameNameResponse500
) & {
  headers: Headers;
};

export type getGamesGameNameResponse =
  | getGamesGameNameResponseSuccess
  | getGamesGameNameResponseError;

export const getGetGamesGameNameUrl = (gameName: string) => {
  return `/games/${gameName}`;
};

export const getGamesGameName = async (
  gameName: string,
  options?: RequestInit,
): Promise<getGamesGameNameResponse> => {
  return rnFetch<getGamesGameNameResponse>(getGetGamesGameNameUrl(gameName), {
    ...options,
    method: "GET",
  });
};

export const getGetGamesGameNameQueryKey = (gameName?: string) => {
  return [`/games/${gameName}`] as const;
};

export const getGetGamesGameNameQueryOptions = <
  TData = Awaited<ReturnType<typeof getGamesGameName>>,
  TError = Error,
>(
  gameName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGamesGameName>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetGamesGameNameQueryKey(gameName);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getGamesGameName>>
  > = ({ signal }) => getGamesGameName(gameName, { signal, ...requestOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!gameName,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getGamesGameName>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetGamesGameNameQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGamesGameName>>
>;
export type GetGamesGameNameQueryError = Error;

export function useGetGamesGameName<
  TData = Awaited<ReturnType<typeof getGamesGameName>>,
  TError = Error,
>(
  gameName: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGamesGameName>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGamesGameName>>,
          TError,
          Awaited<ReturnType<typeof getGamesGameName>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGamesGameName<
  TData = Awaited<ReturnType<typeof getGamesGameName>>,
  TError = Error,
>(
  gameName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGamesGameName>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getGamesGameName>>,
          TError,
          Awaited<ReturnType<typeof getGamesGameName>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetGamesGameName<
  TData = Awaited<ReturnType<typeof getGamesGameName>>,
  TError = Error,
>(
  gameName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGamesGameName>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetGamesGameName<
  TData = Awaited<ReturnType<typeof getGamesGameName>>,
  TError = Error,
>(
  gameName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getGamesGameName>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetGamesGameNameQueryOptions(gameName, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type postPuzzlesMemoryResponse201 = {
  data: MemoryPuzzleCreated;
  status: 201;
};

export type postPuzzlesMemoryResponse400 = {
  data: Error;
  status: 400;
};

export type postPuzzlesMemoryResponse500 = {
  data: Error;
  status: 500;
};

export type postPuzzlesMemoryResponseSuccess = postPuzzlesMemoryResponse201 & {
  headers: Headers;
};
export type postPuzzlesMemoryResponseError = (
  | postPuzzlesMemoryResponse400
  | postPuzzlesMemoryResponse500
) & {
  headers: Headers;
};

export type postPuzzlesMemoryResponse =
  | postPuzzlesMemoryResponseSuccess
  | postPuzzlesMemoryResponseError;

export const getPostPuzzlesMemoryUrl = () => {
  return `/puzzles/memory`;
};

export const postPuzzlesMemory = async (
  newMemoryPuzzle: NewMemoryPuzzle,
  options?: RequestInit,
): Promise<postPuzzlesMemoryResponse> => {
  return rnFetch<postPuzzlesMemoryResponse>(getPostPuzzlesMemoryUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(newMemoryPuzzle),
  });
};

export const getPostPuzzlesMemoryMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postPuzzlesMemory>>,
    TError,
    { data: NewMemoryPuzzle },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postPuzzlesMemory>>,
  TError,
  { data: NewMemoryPuzzle },
  TContext
> => {
  const mutationKey = ["postPuzzlesMemory"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postPuzzlesMemory>>,
    { data: NewMemoryPuzzle }
  > = (props) => {
    const { data } = props ?? {};

    return postPuzzlesMemory(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostPuzzlesMemoryMutationResult = NonNullable<
  Awaited<ReturnType<typeof postPuzzlesMemory>>
>;
export type PostPuzzlesMemoryMutationBody = NewMemoryPuzzle;
export type PostPuzzlesMemoryMutationError = Error;

export const usePostPuzzlesMemory = <TError = Error, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postPuzzlesMemory>>,
      TError,
      { data: NewMemoryPuzzle },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postPuzzlesMemory>>,
  TError,
  { data: NewMemoryPuzzle },
  TContext
> => {
  const mutationOptions = getPostPuzzlesMemoryMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type postPuzzlesSudokuResponse201 = {
  data: PostPuzzlesSudoku201;
  status: 201;
};

export type postPuzzlesSudokuResponse400 = {
  data: Error;
  status: 400;
};

export type postPuzzlesSudokuResponse500 = {
  data: Error;
  status: 500;
};

export type postPuzzlesSudokuResponseSuccess = postPuzzlesSudokuResponse201 & {
  headers: Headers;
};
export type postPuzzlesSudokuResponseError = (
  | postPuzzlesSudokuResponse400
  | postPuzzlesSudokuResponse500
) & {
  headers: Headers;
};

export type postPuzzlesSudokuResponse =
  | postPuzzlesSudokuResponseSuccess
  | postPuzzlesSudokuResponseError;

export const getPostPuzzlesSudokuUrl = () => {
  return `/puzzles/sudoku`;
};

export const postPuzzlesSudoku = async (
  newSudokuPuzzle: NewSudokuPuzzle,
  options?: RequestInit,
): Promise<postPuzzlesSudokuResponse> => {
  return rnFetch<postPuzzlesSudokuResponse>(getPostPuzzlesSudokuUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(newSudokuPuzzle),
  });
};

export const getPostPuzzlesSudokuMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postPuzzlesSudoku>>,
    TError,
    { data: NewSudokuPuzzle },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postPuzzlesSudoku>>,
  TError,
  { data: NewSudokuPuzzle },
  TContext
> => {
  const mutationKey = ["postPuzzlesSudoku"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postPuzzlesSudoku>>,
    { data: NewSudokuPuzzle }
  > = (props) => {
    const { data } = props ?? {};

    return postPuzzlesSudoku(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostPuzzlesSudokuMutationResult = NonNullable<
  Awaited<ReturnType<typeof postPuzzlesSudoku>>
>;
export type PostPuzzlesSudokuMutationBody = NewSudokuPuzzle;
export type PostPuzzlesSudokuMutationError = Error;

export const usePostPuzzlesSudoku = <TError = Error, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postPuzzlesSudoku>>,
      TError,
      { data: NewSudokuPuzzle },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postPuzzlesSudoku>>,
  TError,
  { data: NewSudokuPuzzle },
  TContext
> => {
  const mutationOptions = getPostPuzzlesSudokuMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type postPuzzlesNetResponse201 = {
  data: LogicPuzzleCreated;
  status: 201;
};

export type postPuzzlesNetResponse400 = {
  data: Error;
  status: 400;
};

export type postPuzzlesNetResponse500 = {
  data: Error;
  status: 500;
};

export type postPuzzlesNetResponseSuccess = postPuzzlesNetResponse201 & {
  headers: Headers;
};
export type postPuzzlesNetResponseError = (
  | postPuzzlesNetResponse400
  | postPuzzlesNetResponse500
) & {
  headers: Headers;
};

export type postPuzzlesNetResponse =
  | postPuzzlesNetResponseSuccess
  | postPuzzlesNetResponseError;

export const getPostPuzzlesNetUrl = () => {
  return `/puzzles/net`;
};

export const postPuzzlesNet = async (
  newNetPuzzle: NewNetPuzzle,
  options?: RequestInit,
): Promise<postPuzzlesNetResponse> => {
  return rnFetch<postPuzzlesNetResponse>(getPostPuzzlesNetUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(newNetPuzzle),
  });
};

export const getPostPuzzlesNetMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postPuzzlesNet>>,
    TError,
    { data: NewNetPuzzle },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postPuzzlesNet>>,
  TError,
  { data: NewNetPuzzle },
  TContext
> => {
  const mutationKey = ["postPuzzlesNet"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postPuzzlesNet>>,
    { data: NewNetPuzzle }
  > = (props) => {
    const { data } = props ?? {};

    return postPuzzlesNet(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostPuzzlesNetMutationResult = NonNullable<
  Awaited<ReturnType<typeof postPuzzlesNet>>
>;
export type PostPuzzlesNetMutationBody = NewNetPuzzle;
export type PostPuzzlesNetMutationError = Error;

export const usePostPuzzlesNet = <TError = Error, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postPuzzlesNet>>,
      TError,
      { data: NewNetPuzzle },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postPuzzlesNet>>,
  TError,
  { data: NewNetPuzzle },
  TContext
> => {
  const mutationOptions = getPostPuzzlesNetMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type postPuzzlesFocusResponse201 = {
  data: FocusPuzzleCreated;
  status: 201;
};

export type postPuzzlesFocusResponse400 = {
  data: Error;
  status: 400;
};

export type postPuzzlesFocusResponse500 = {
  data: Error;
  status: 500;
};

export type postPuzzlesFocusResponseSuccess = postPuzzlesFocusResponse201 & {
  headers: Headers;
};
export type postPuzzlesFocusResponseError = (
  | postPuzzlesFocusResponse400
  | postPuzzlesFocusResponse500
) & {
  headers: Headers;
};

export type postPuzzlesFocusResponse =
  | postPuzzlesFocusResponseSuccess
  | postPuzzlesFocusResponseError;

export const getPostPuzzlesFocusUrl = () => {
  return `/puzzles/focus`;
};

export const postPuzzlesFocus = async (
  newFocusPuzzle: NewFocusPuzzle,
  options?: RequestInit,
): Promise<postPuzzlesFocusResponse> => {
  return rnFetch<postPuzzlesFocusResponse>(getPostPuzzlesFocusUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(newFocusPuzzle),
  });
};

export const getPostPuzzlesFocusMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postPuzzlesFocus>>,
    TError,
    { data: NewFocusPuzzle },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postPuzzlesFocus>>,
  TError,
  { data: NewFocusPuzzle },
  TContext
> => {
  const mutationKey = ["postPuzzlesFocus"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postPuzzlesFocus>>,
    { data: NewFocusPuzzle }
  > = (props) => {
    const { data } = props ?? {};

    return postPuzzlesFocus(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostPuzzlesFocusMutationResult = NonNullable<
  Awaited<ReturnType<typeof postPuzzlesFocus>>
>;
export type PostPuzzlesFocusMutationBody = NewFocusPuzzle;
export type PostPuzzlesFocusMutationError = Error;

export const usePostPuzzlesFocus = <TError = Error, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postPuzzlesFocus>>,
      TError,
      { data: NewFocusPuzzle },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postPuzzlesFocus>>,
  TError,
  { data: NewFocusPuzzle },
  TContext
> => {
  const mutationOptions = getPostPuzzlesFocusMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type getPuzzlesRecentGameTypeResponse200 = {
  data: Puzzle[];
  status: 200;
};

export type getPuzzlesRecentGameTypeResponse500 = {
  data: Error;
  status: 500;
};

export type getPuzzlesRecentGameTypeResponseSuccess =
  getPuzzlesRecentGameTypeResponse200 & {
    headers: Headers;
  };
export type getPuzzlesRecentGameTypeResponseError =
  getPuzzlesRecentGameTypeResponse500 & {
    headers: Headers;
  };

export type getPuzzlesRecentGameTypeResponse =
  | getPuzzlesRecentGameTypeResponseSuccess
  | getPuzzlesRecentGameTypeResponseError;

export const getGetPuzzlesRecentGameTypeUrl = (
  gameType: GameType,
  params?: GetPuzzlesRecentGameTypeParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/puzzles/recent/${gameType}?${stringifiedParams}`
    : `/puzzles/recent/${gameType}`;
};

export const getPuzzlesRecentGameType = async (
  gameType: GameType,
  params?: GetPuzzlesRecentGameTypeParams,
  options?: RequestInit,
): Promise<getPuzzlesRecentGameTypeResponse> => {
  return rnFetch<getPuzzlesRecentGameTypeResponse>(
    getGetPuzzlesRecentGameTypeUrl(gameType, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetPuzzlesRecentGameTypeQueryKey = (
  gameType?: GameType,
  params?: GetPuzzlesRecentGameTypeParams,
) => {
  return [`/puzzles/recent/${gameType}`, ...(params ? [params] : [])] as const;
};

export const getGetPuzzlesRecentGameTypeQueryOptions = <
  TData = Awaited<ReturnType<typeof getPuzzlesRecentGameType>>,
  TError = Error,
>(
  gameType: GameType,
  params?: GetPuzzlesRecentGameTypeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPuzzlesRecentGameType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetPuzzlesRecentGameTypeQueryKey(gameType, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPuzzlesRecentGameType>>
  > = ({ signal }) =>
    getPuzzlesRecentGameType(gameType, params, { signal, ...requestOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!gameType,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getPuzzlesRecentGameType>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetPuzzlesRecentGameTypeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPuzzlesRecentGameType>>
>;
export type GetPuzzlesRecentGameTypeQueryError = Error;

export function useGetPuzzlesRecentGameType<
  TData = Awaited<ReturnType<typeof getPuzzlesRecentGameType>>,
  TError = Error,
>(
  gameType: GameType,
  params: undefined | GetPuzzlesRecentGameTypeParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPuzzlesRecentGameType>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPuzzlesRecentGameType>>,
          TError,
          Awaited<ReturnType<typeof getPuzzlesRecentGameType>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPuzzlesRecentGameType<
  TData = Awaited<ReturnType<typeof getPuzzlesRecentGameType>>,
  TError = Error,
>(
  gameType: GameType,
  params?: GetPuzzlesRecentGameTypeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPuzzlesRecentGameType>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPuzzlesRecentGameType>>,
          TError,
          Awaited<ReturnType<typeof getPuzzlesRecentGameType>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetPuzzlesRecentGameType<
  TData = Awaited<ReturnType<typeof getPuzzlesRecentGameType>>,
  TError = Error,
>(
  gameType: GameType,
  params?: GetPuzzlesRecentGameTypeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPuzzlesRecentGameType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetPuzzlesRecentGameType<
  TData = Awaited<ReturnType<typeof getPuzzlesRecentGameType>>,
  TError = Error,
>(
  gameType: GameType,
  params?: GetPuzzlesRecentGameTypeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPuzzlesRecentGameType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetPuzzlesRecentGameTypeQueryOptions(
    gameType,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type postAttemptsStartResponse201 = {
  data: PostAttemptsStart201;
  status: 201;
};

export type postAttemptsStartResponse404 = {
  data: Error;
  status: 404;
};

export type postAttemptsStartResponse500 = {
  data: Error;
  status: 500;
};

export type postAttemptsStartResponseSuccess = postAttemptsStartResponse201 & {
  headers: Headers;
};
export type postAttemptsStartResponseError = (
  | postAttemptsStartResponse404
  | postAttemptsStartResponse500
) & {
  headers: Headers;
};

export type postAttemptsStartResponse =
  | postAttemptsStartResponseSuccess
  | postAttemptsStartResponseError;

export const getPostAttemptsStartUrl = () => {
  return `/attempts/start`;
};

export const postAttemptsStart = async (
  startAttempt: StartAttempt,
  options?: RequestInit,
): Promise<postAttemptsStartResponse> => {
  return rnFetch<postAttemptsStartResponse>(getPostAttemptsStartUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(startAttempt),
  });
};

export const getPostAttemptsStartMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAttemptsStart>>,
    TError,
    { data: StartAttempt },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAttemptsStart>>,
  TError,
  { data: StartAttempt },
  TContext
> => {
  const mutationKey = ["postAttemptsStart"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAttemptsStart>>,
    { data: StartAttempt }
  > = (props) => {
    const { data } = props ?? {};

    return postAttemptsStart(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAttemptsStartMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAttemptsStart>>
>;
export type PostAttemptsStartMutationBody = StartAttempt;
export type PostAttemptsStartMutationError = Error;

export const usePostAttemptsStart = <TError = Error, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAttemptsStart>>,
      TError,
      { data: StartAttempt },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAttemptsStart>>,
  TError,
  { data: StartAttempt },
  TContext
> => {
  const mutationOptions = getPostAttemptsStartMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type postAttemptsAttemptIdFinishResponse200 = {
  data: PostAttemptsAttemptIdFinish200;
  status: 200;
};

export type postAttemptsAttemptIdFinishResponse400 = {
  data: Error;
  status: 400;
};

export type postAttemptsAttemptIdFinishResponse403 = {
  data: Error;
  status: 403;
};

export type postAttemptsAttemptIdFinishResponse404 = {
  data: Error;
  status: 404;
};

export type postAttemptsAttemptIdFinishResponse500 = {
  data: Error;
  status: 500;
};

export type postAttemptsAttemptIdFinishResponseSuccess =
  postAttemptsAttemptIdFinishResponse200 & {
    headers: Headers;
  };
export type postAttemptsAttemptIdFinishResponseError = (
  | postAttemptsAttemptIdFinishResponse400
  | postAttemptsAttemptIdFinishResponse403
  | postAttemptsAttemptIdFinishResponse404
  | postAttemptsAttemptIdFinishResponse500
) & {
  headers: Headers;
};

export type postAttemptsAttemptIdFinishResponse =
  | postAttemptsAttemptIdFinishResponseSuccess
  | postAttemptsAttemptIdFinishResponseError;

export const getPostAttemptsAttemptIdFinishUrl = (attemptId: string) => {
  return `/attempts/${attemptId}/finish`;
};

export const postAttemptsAttemptIdFinish = async (
  attemptId: string,
  finishAttempt: FinishAttempt,
  options?: RequestInit,
): Promise<postAttemptsAttemptIdFinishResponse> => {
  return rnFetch<postAttemptsAttemptIdFinishResponse>(
    getPostAttemptsAttemptIdFinishUrl(attemptId),
    {
      ...options,
      method: "POST",
      headers: { "Content-Type": "application/json", ...options?.headers },
      body: JSON.stringify(finishAttempt),
    },
  );
};

export const getPostAttemptsAttemptIdFinishMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAttemptsAttemptIdFinish>>,
    TError,
    { attemptId: string; data: FinishAttempt },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAttemptsAttemptIdFinish>>,
  TError,
  { attemptId: string; data: FinishAttempt },
  TContext
> => {
  const mutationKey = ["postAttemptsAttemptIdFinish"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAttemptsAttemptIdFinish>>,
    { attemptId: string; data: FinishAttempt }
  > = (props) => {
    const { attemptId, data } = props ?? {};

    return postAttemptsAttemptIdFinish(attemptId, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAttemptsAttemptIdFinishMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAttemptsAttemptIdFinish>>
>;
export type PostAttemptsAttemptIdFinishMutationBody = FinishAttempt;
export type PostAttemptsAttemptIdFinishMutationError = Error;

export const usePostAttemptsAttemptIdFinish = <
  TError = Error,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAttemptsAttemptIdFinish>>,
      TError,
      { attemptId: string; data: FinishAttempt },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAttemptsAttemptIdFinish>>,
  TError,
  { attemptId: string; data: FinishAttempt },
  TContext
> => {
  const mutationOptions =
    getPostAttemptsAttemptIdFinishMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type getAttemptsAttemptIdResponse200 = {
  data: GetAttemptsAttemptId200;
  status: 200;
};

export type getAttemptsAttemptIdResponse404 = {
  data: Error;
  status: 404;
};

export type getAttemptsAttemptIdResponse500 = {
  data: Error;
  status: 500;
};

export type getAttemptsAttemptIdResponseSuccess =
  getAttemptsAttemptIdResponse200 & {
    headers: Headers;
  };
export type getAttemptsAttemptIdResponseError = (
  | getAttemptsAttemptIdResponse404
  | getAttemptsAttemptIdResponse500
) & {
  headers: Headers;
};

export type getAttemptsAttemptIdResponse =
  | getAttemptsAttemptIdResponseSuccess
  | getAttemptsAttemptIdResponseError;

export const getGetAttemptsAttemptIdUrl = (attemptId: string) => {
  return `/attempts/${attemptId}`;
};

export const getAttemptsAttemptId = async (
  attemptId: string,
  options?: RequestInit,
): Promise<getAttemptsAttemptIdResponse> => {
  return rnFetch<getAttemptsAttemptIdResponse>(
    getGetAttemptsAttemptIdUrl(attemptId),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetAttemptsAttemptIdQueryKey = (attemptId?: string) => {
  return [`/attempts/${attemptId}`] as const;
};

export const getGetAttemptsAttemptIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getAttemptsAttemptId>>,
  TError = Error,
>(
  attemptId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAttemptsAttemptId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAttemptsAttemptIdQueryKey(attemptId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAttemptsAttemptId>>
  > = ({ signal }) =>
    getAttemptsAttemptId(attemptId, { signal, ...requestOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!attemptId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAttemptsAttemptId>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAttemptsAttemptIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAttemptsAttemptId>>
>;
export type GetAttemptsAttemptIdQueryError = Error;

export function useGetAttemptsAttemptId<
  TData = Awaited<ReturnType<typeof getAttemptsAttemptId>>,
  TError = Error,
>(
  attemptId: string,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAttemptsAttemptId>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAttemptsAttemptId>>,
          TError,
          Awaited<ReturnType<typeof getAttemptsAttemptId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAttemptsAttemptId<
  TData = Awaited<ReturnType<typeof getAttemptsAttemptId>>,
  TError = Error,
>(
  attemptId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAttemptsAttemptId>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAttemptsAttemptId>>,
          TError,
          Awaited<ReturnType<typeof getAttemptsAttemptId>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAttemptsAttemptId<
  TData = Awaited<ReturnType<typeof getAttemptsAttemptId>>,
  TError = Error,
>(
  attemptId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAttemptsAttemptId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetAttemptsAttemptId<
  TData = Awaited<ReturnType<typeof getAttemptsAttemptId>>,
  TError = Error,
>(
  attemptId: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAttemptsAttemptId>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAttemptsAttemptIdQueryOptions(attemptId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type getAttemptsResponse200 = {
  data: AttemptWithUser[];
  status: 200;
};

export type getAttemptsResponse403 = {
  data: Error;
  status: 403;
};

export type getAttemptsResponse500 = {
  data: Error;
  status: 500;
};

export type getAttemptsResponseSuccess = getAttemptsResponse200 & {
  headers: Headers;
};
export type getAttemptsResponseError = (
  | getAttemptsResponse403
  | getAttemptsResponse500
) & {
  headers: Headers;
};

export type getAttemptsResponse =
  | getAttemptsResponseSuccess
  | getAttemptsResponseError;

export const getGetAttemptsUrl = (params?: GetAttemptsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/attempts?${stringifiedParams}`
    : `/attempts`;
};

export const getAttempts = async (
  params?: GetAttemptsParams,
  options?: RequestInit,
): Promise<getAttemptsResponse> => {
  return rnFetch<getAttemptsResponse>(getGetAttemptsUrl(params), {
    ...options,
    method: "GET",
  });
};

export const getGetAttemptsQueryKey = (params?: GetAttemptsParams) => {
  return [`/attempts`, ...(params ? [params] : [])] as const;
};

export const getGetAttemptsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAttempts>>,
  TError = Error,
>(
  params?: GetAttemptsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAttempts>>, TError, TData>
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetAttemptsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAttempts>>> = ({
    signal,
  }) => getAttempts(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getAttempts>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAttemptsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAttempts>>
>;
export type GetAttemptsQueryError = Error;

export function useGetAttempts<
  TData = Awaited<ReturnType<typeof getAttempts>>,
  TError = Error,
>(
  params: undefined | GetAttemptsParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAttempts>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAttempts>>,
          TError,
          Awaited<ReturnType<typeof getAttempts>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAttempts<
  TData = Awaited<ReturnType<typeof getAttempts>>,
  TError = Error,
>(
  params?: GetAttemptsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAttempts>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAttempts>>,
          TError,
          Awaited<ReturnType<typeof getAttempts>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAttempts<
  TData = Awaited<ReturnType<typeof getAttempts>>,
  TError = Error,
>(
  params?: GetAttemptsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAttempts>>, TError, TData>
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetAttempts<
  TData = Awaited<ReturnType<typeof getAttempts>>,
  TError = Error,
>(
  params?: GetAttemptsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAttempts>>, TError, TData>
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAttemptsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type getAttemptsStatsGameTypeResponse200 = {
  data: AttemptStats;
  status: 200;
};

export type getAttemptsStatsGameTypeResponse403 = {
  data: Error;
  status: 403;
};

export type getAttemptsStatsGameTypeResponse500 = {
  data: Error;
  status: 500;
};

export type getAttemptsStatsGameTypeResponseSuccess =
  getAttemptsStatsGameTypeResponse200 & {
    headers: Headers;
  };
export type getAttemptsStatsGameTypeResponseError = (
  | getAttemptsStatsGameTypeResponse403
  | getAttemptsStatsGameTypeResponse500
) & {
  headers: Headers;
};

export type getAttemptsStatsGameTypeResponse =
  | getAttemptsStatsGameTypeResponseSuccess
  | getAttemptsStatsGameTypeResponseError;

export const getGetAttemptsStatsGameTypeUrl = (
  gameType: GameType,
  params?: GetAttemptsStatsGameTypeParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/attempts/stats/${gameType}?${stringifiedParams}`
    : `/attempts/stats/${gameType}`;
};

export const getAttemptsStatsGameType = async (
  gameType: GameType,
  params?: GetAttemptsStatsGameTypeParams,
  options?: RequestInit,
): Promise<getAttemptsStatsGameTypeResponse> => {
  return rnFetch<getAttemptsStatsGameTypeResponse>(
    getGetAttemptsStatsGameTypeUrl(gameType, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetAttemptsStatsGameTypeQueryKey = (
  gameType?: GameType,
  params?: GetAttemptsStatsGameTypeParams,
) => {
  return [`/attempts/stats/${gameType}`, ...(params ? [params] : [])] as const;
};

export const getGetAttemptsStatsGameTypeQueryOptions = <
  TData = Awaited<ReturnType<typeof getAttemptsStatsGameType>>,
  TError = Error,
>(
  gameType: GameType,
  params?: GetAttemptsStatsGameTypeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAttemptsStatsGameType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetAttemptsStatsGameTypeQueryKey(gameType, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAttemptsStatsGameType>>
  > = ({ signal }) =>
    getAttemptsStatsGameType(gameType, params, { signal, ...requestOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!gameType,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAttemptsStatsGameType>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAttemptsStatsGameTypeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAttemptsStatsGameType>>
>;
export type GetAttemptsStatsGameTypeQueryError = Error;

export function useGetAttemptsStatsGameType<
  TData = Awaited<ReturnType<typeof getAttemptsStatsGameType>>,
  TError = Error,
>(
  gameType: GameType,
  params: undefined | GetAttemptsStatsGameTypeParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAttemptsStatsGameType>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAttemptsStatsGameType>>,
          TError,
          Awaited<ReturnType<typeof getAttemptsStatsGameType>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAttemptsStatsGameType<
  TData = Awaited<ReturnType<typeof getAttemptsStatsGameType>>,
  TError = Error,
>(
  gameType: GameType,
  params?: GetAttemptsStatsGameTypeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAttemptsStatsGameType>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAttemptsStatsGameType>>,
          TError,
          Awaited<ReturnType<typeof getAttemptsStatsGameType>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAttemptsStatsGameType<
  TData = Awaited<ReturnType<typeof getAttemptsStatsGameType>>,
  TError = Error,
>(
  gameType: GameType,
  params?: GetAttemptsStatsGameTypeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAttemptsStatsGameType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetAttemptsStatsGameType<
  TData = Awaited<ReturnType<typeof getAttemptsStatsGameType>>,
  TError = Error,
>(
  gameType: GameType,
  params?: GetAttemptsStatsGameTypeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAttemptsStatsGameType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAttemptsStatsGameTypeQueryOptions(
    gameType,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type getAttemptsLeaderboardGameTypeResponse200 = {
  data: GetAttemptsLeaderboardGameType200Item[];
  status: 200;
};

export type getAttemptsLeaderboardGameTypeResponse500 = {
  data: Error;
  status: 500;
};

export type getAttemptsLeaderboardGameTypeResponseSuccess =
  getAttemptsLeaderboardGameTypeResponse200 & {
    headers: Headers;
  };
export type getAttemptsLeaderboardGameTypeResponseError =
  getAttemptsLeaderboardGameTypeResponse500 & {
    headers: Headers;
  };

export type getAttemptsLeaderboardGameTypeResponse =
  | getAttemptsLeaderboardGameTypeResponseSuccess
  | getAttemptsLeaderboardGameTypeResponseError;

export const getGetAttemptsLeaderboardGameTypeUrl = (
  gameType: GameType,
  params?: GetAttemptsLeaderboardGameTypeParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/attempts/leaderboard/${gameType}?${stringifiedParams}`
    : `/attempts/leaderboard/${gameType}`;
};

export const getAttemptsLeaderboardGameType = async (
  gameType: GameType,
  params?: GetAttemptsLeaderboardGameTypeParams,
  options?: RequestInit,
): Promise<getAttemptsLeaderboardGameTypeResponse> => {
  return rnFetch<getAttemptsLeaderboardGameTypeResponse>(
    getGetAttemptsLeaderboardGameTypeUrl(gameType, params),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetAttemptsLeaderboardGameTypeQueryKey = (
  gameType?: GameType,
  params?: GetAttemptsLeaderboardGameTypeParams,
) => {
  return [
    `/attempts/leaderboard/${gameType}`,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetAttemptsLeaderboardGameTypeQueryOptions = <
  TData = Awaited<ReturnType<typeof getAttemptsLeaderboardGameType>>,
  TError = Error,
>(
  gameType: GameType,
  params?: GetAttemptsLeaderboardGameTypeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAttemptsLeaderboardGameType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetAttemptsLeaderboardGameTypeQueryKey(gameType, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAttemptsLeaderboardGameType>>
  > = ({ signal }) =>
    getAttemptsLeaderboardGameType(gameType, params, {
      signal,
      ...requestOptions,
    });

  return {
    queryKey,
    queryFn,
    enabled: !!gameType,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAttemptsLeaderboardGameType>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAttemptsLeaderboardGameTypeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAttemptsLeaderboardGameType>>
>;
export type GetAttemptsLeaderboardGameTypeQueryError = Error;

export function useGetAttemptsLeaderboardGameType<
  TData = Awaited<ReturnType<typeof getAttemptsLeaderboardGameType>>,
  TError = Error,
>(
  gameType: GameType,
  params: undefined | GetAttemptsLeaderboardGameTypeParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAttemptsLeaderboardGameType>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAttemptsLeaderboardGameType>>,
          TError,
          Awaited<ReturnType<typeof getAttemptsLeaderboardGameType>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAttemptsLeaderboardGameType<
  TData = Awaited<ReturnType<typeof getAttemptsLeaderboardGameType>>,
  TError = Error,
>(
  gameType: GameType,
  params?: GetAttemptsLeaderboardGameTypeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAttemptsLeaderboardGameType>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAttemptsLeaderboardGameType>>,
          TError,
          Awaited<ReturnType<typeof getAttemptsLeaderboardGameType>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAttemptsLeaderboardGameType<
  TData = Awaited<ReturnType<typeof getAttemptsLeaderboardGameType>>,
  TError = Error,
>(
  gameType: GameType,
  params?: GetAttemptsLeaderboardGameTypeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAttemptsLeaderboardGameType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetAttemptsLeaderboardGameType<
  TData = Awaited<ReturnType<typeof getAttemptsLeaderboardGameType>>,
  TError = Error,
>(
  gameType: GameType,
  params?: GetAttemptsLeaderboardGameTypeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAttemptsLeaderboardGameType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAttemptsLeaderboardGameTypeQueryOptions(
    gameType,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type getAchievementsGameTypeResponse200 = {
  data: GetAchievementsGameType200Item[];
  status: 200;
};

export type getAchievementsGameTypeResponse500 = {
  data: Error;
  status: 500;
};

export type getAchievementsGameTypeResponseSuccess =
  getAchievementsGameTypeResponse200 & {
    headers: Headers;
  };
export type getAchievementsGameTypeResponseError =
  getAchievementsGameTypeResponse500 & {
    headers: Headers;
  };

export type getAchievementsGameTypeResponse =
  | getAchievementsGameTypeResponseSuccess
  | getAchievementsGameTypeResponseError;

export const getGetAchievementsGameTypeUrl = (gameType: GameType) => {
  return `/achievements/${gameType}`;
};

export const getAchievementsGameType = async (
  gameType: GameType,
  options?: RequestInit,
): Promise<getAchievementsGameTypeResponse> => {
  return rnFetch<getAchievementsGameTypeResponse>(
    getGetAchievementsGameTypeUrl(gameType),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetAchievementsGameTypeQueryKey = (gameType?: GameType) => {
  return [`/achievements/${gameType}`] as const;
};

export const getGetAchievementsGameTypeQueryOptions = <
  TData = Awaited<ReturnType<typeof getAchievementsGameType>>,
  TError = Error,
>(
  gameType: GameType,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAchievementsGameType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAchievementsGameTypeQueryKey(gameType);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAchievementsGameType>>
  > = ({ signal }) =>
    getAchievementsGameType(gameType, { signal, ...requestOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!gameType,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAchievementsGameType>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAchievementsGameTypeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAchievementsGameType>>
>;
export type GetAchievementsGameTypeQueryError = Error;

export function useGetAchievementsGameType<
  TData = Awaited<ReturnType<typeof getAchievementsGameType>>,
  TError = Error,
>(
  gameType: GameType,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAchievementsGameType>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAchievementsGameType>>,
          TError,
          Awaited<ReturnType<typeof getAchievementsGameType>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAchievementsGameType<
  TData = Awaited<ReturnType<typeof getAchievementsGameType>>,
  TError = Error,
>(
  gameType: GameType,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAchievementsGameType>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAchievementsGameType>>,
          TError,
          Awaited<ReturnType<typeof getAchievementsGameType>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAchievementsGameType<
  TData = Awaited<ReturnType<typeof getAchievementsGameType>>,
  TError = Error,
>(
  gameType: GameType,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAchievementsGameType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetAchievementsGameType<
  TData = Awaited<ReturnType<typeof getAchievementsGameType>>,
  TError = Error,
>(
  gameType: GameType,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAchievementsGameType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAchievementsGameTypeQueryOptions(
    gameType,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type getAchievementsUserGameTypeResponse200 = {
  data: GetAchievementsUserGameType200Item[];
  status: 200;
};

export type getAchievementsUserGameTypeResponse500 = {
  data: Error;
  status: 500;
};

export type getAchievementsUserGameTypeResponseSuccess =
  getAchievementsUserGameTypeResponse200 & {
    headers: Headers;
  };
export type getAchievementsUserGameTypeResponseError =
  getAchievementsUserGameTypeResponse500 & {
    headers: Headers;
  };

export type getAchievementsUserGameTypeResponse =
  | getAchievementsUserGameTypeResponseSuccess
  | getAchievementsUserGameTypeResponseError;

export const getGetAchievementsUserGameTypeUrl = (gameType: GameType) => {
  return `/achievements/user/${gameType}`;
};

export const getAchievementsUserGameType = async (
  gameType: GameType,
  options?: RequestInit,
): Promise<getAchievementsUserGameTypeResponse> => {
  return rnFetch<getAchievementsUserGameTypeResponse>(
    getGetAchievementsUserGameTypeUrl(gameType),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetAchievementsUserGameTypeQueryKey = (gameType?: GameType) => {
  return [`/achievements/user/${gameType}`] as const;
};

export const getGetAchievementsUserGameTypeQueryOptions = <
  TData = Awaited<ReturnType<typeof getAchievementsUserGameType>>,
  TError = Error,
>(
  gameType: GameType,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAchievementsUserGameType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetAchievementsUserGameTypeQueryKey(gameType);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAchievementsUserGameType>>
  > = ({ signal }) =>
    getAchievementsUserGameType(gameType, { signal, ...requestOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!gameType,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAchievementsUserGameType>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAchievementsUserGameTypeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAchievementsUserGameType>>
>;
export type GetAchievementsUserGameTypeQueryError = Error;

export function useGetAchievementsUserGameType<
  TData = Awaited<ReturnType<typeof getAchievementsUserGameType>>,
  TError = Error,
>(
  gameType: GameType,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAchievementsUserGameType>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAchievementsUserGameType>>,
          TError,
          Awaited<ReturnType<typeof getAchievementsUserGameType>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAchievementsUserGameType<
  TData = Awaited<ReturnType<typeof getAchievementsUserGameType>>,
  TError = Error,
>(
  gameType: GameType,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAchievementsUserGameType>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAchievementsUserGameType>>,
          TError,
          Awaited<ReturnType<typeof getAchievementsUserGameType>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAchievementsUserGameType<
  TData = Awaited<ReturnType<typeof getAchievementsUserGameType>>,
  TError = Error,
>(
  gameType: GameType,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAchievementsUserGameType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetAchievementsUserGameType<
  TData = Awaited<ReturnType<typeof getAchievementsUserGameType>>,
  TError = Error,
>(
  gameType: GameType,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAchievementsUserGameType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAchievementsUserGameTypeQueryOptions(
    gameType,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type getAchievementsProgressGameTypeResponse200 = {
  data: AchievementProgress;
  status: 200;
};

export type getAchievementsProgressGameTypeResponse500 = {
  data: Error;
  status: 500;
};

export type getAchievementsProgressGameTypeResponseSuccess =
  getAchievementsProgressGameTypeResponse200 & {
    headers: Headers;
  };
export type getAchievementsProgressGameTypeResponseError =
  getAchievementsProgressGameTypeResponse500 & {
    headers: Headers;
  };

export type getAchievementsProgressGameTypeResponse =
  | getAchievementsProgressGameTypeResponseSuccess
  | getAchievementsProgressGameTypeResponseError;

export const getGetAchievementsProgressGameTypeUrl = (gameType: GameType) => {
  return `/achievements/progress/${gameType}`;
};

export const getAchievementsProgressGameType = async (
  gameType: GameType,
  options?: RequestInit,
): Promise<getAchievementsProgressGameTypeResponse> => {
  return rnFetch<getAchievementsProgressGameTypeResponse>(
    getGetAchievementsProgressGameTypeUrl(gameType),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetAchievementsProgressGameTypeQueryKey = (
  gameType?: GameType,
) => {
  return [`/achievements/progress/${gameType}`] as const;
};

export const getGetAchievementsProgressGameTypeQueryOptions = <
  TData = Awaited<ReturnType<typeof getAchievementsProgressGameType>>,
  TError = Error,
>(
  gameType: GameType,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAchievementsProgressGameType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getGetAchievementsProgressGameTypeQueryKey(gameType);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAchievementsProgressGameType>>
  > = ({ signal }) =>
    getAchievementsProgressGameType(gameType, { signal, ...requestOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!gameType,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getAchievementsProgressGameType>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetAchievementsProgressGameTypeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAchievementsProgressGameType>>
>;
export type GetAchievementsProgressGameTypeQueryError = Error;

export function useGetAchievementsProgressGameType<
  TData = Awaited<ReturnType<typeof getAchievementsProgressGameType>>,
  TError = Error,
>(
  gameType: GameType,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAchievementsProgressGameType>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAchievementsProgressGameType>>,
          TError,
          Awaited<ReturnType<typeof getAchievementsProgressGameType>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAchievementsProgressGameType<
  TData = Awaited<ReturnType<typeof getAchievementsProgressGameType>>,
  TError = Error,
>(
  gameType: GameType,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAchievementsProgressGameType>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getAchievementsProgressGameType>>,
          TError,
          Awaited<ReturnType<typeof getAchievementsProgressGameType>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetAchievementsProgressGameType<
  TData = Awaited<ReturnType<typeof getAchievementsProgressGameType>>,
  TError = Error,
>(
  gameType: GameType,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAchievementsProgressGameType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetAchievementsProgressGameType<
  TData = Awaited<ReturnType<typeof getAchievementsProgressGameType>>,
  TError = Error,
>(
  gameType: GameType,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getAchievementsProgressGameType>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAchievementsProgressGameTypeQueryOptions(
    gameType,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type postAchievementsCheckAttemptIdResponse200 = {
  data: PostAchievementsCheckAttemptId200Item[];
  status: 200;
};

export type postAchievementsCheckAttemptIdResponse404 = {
  data: Error;
  status: 404;
};

export type postAchievementsCheckAttemptIdResponse500 = {
  data: Error;
  status: 500;
};

export type postAchievementsCheckAttemptIdResponseSuccess =
  postAchievementsCheckAttemptIdResponse200 & {
    headers: Headers;
  };
export type postAchievementsCheckAttemptIdResponseError = (
  | postAchievementsCheckAttemptIdResponse404
  | postAchievementsCheckAttemptIdResponse500
) & {
  headers: Headers;
};

export type postAchievementsCheckAttemptIdResponse =
  | postAchievementsCheckAttemptIdResponseSuccess
  | postAchievementsCheckAttemptIdResponseError;

export const getPostAchievementsCheckAttemptIdUrl = (attemptId: string) => {
  return `/achievements/check/${attemptId}`;
};

export const postAchievementsCheckAttemptId = async (
  attemptId: string,
  options?: RequestInit,
): Promise<postAchievementsCheckAttemptIdResponse> => {
  return rnFetch<postAchievementsCheckAttemptIdResponse>(
    getPostAchievementsCheckAttemptIdUrl(attemptId),
    {
      ...options,
      method: "POST",
    },
  );
};

export const getPostAchievementsCheckAttemptIdMutationOptions = <
  TError = Error,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAchievementsCheckAttemptId>>,
    TError,
    { attemptId: string },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAchievementsCheckAttemptId>>,
  TError,
  { attemptId: string },
  TContext
> => {
  const mutationKey = ["postAchievementsCheckAttemptId"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAchievementsCheckAttemptId>>,
    { attemptId: string }
  > = (props) => {
    const { attemptId } = props ?? {};

    return postAchievementsCheckAttemptId(attemptId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAchievementsCheckAttemptIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAchievementsCheckAttemptId>>
>;

export type PostAchievementsCheckAttemptIdMutationError = Error;

export const usePostAchievementsCheckAttemptId = <
  TError = Error,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof postAchievementsCheckAttemptId>>,
      TError,
      { attemptId: string },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof postAchievementsCheckAttemptId>>,
  TError,
  { attemptId: string },
  TContext
> => {
  const mutationOptions =
    getPostAchievementsCheckAttemptIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export type getStreaksMeResponse200 = {
  data: GetStreaksMe200;
  status: 200;
};

export type getStreaksMeResponse500 = {
  data: Error;
  status: 500;
};

export type getStreaksMeResponseSuccess = getStreaksMeResponse200 & {
  headers: Headers;
};
export type getStreaksMeResponseError = getStreaksMeResponse500 & {
  headers: Headers;
};

export type getStreaksMeResponse =
  | getStreaksMeResponseSuccess
  | getStreaksMeResponseError;

export const getGetStreaksMeUrl = (params?: GetStreaksMeParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/streaks/me?${stringifiedParams}`
    : `/streaks/me`;
};

export const getStreaksMe = async (
  params?: GetStreaksMeParams,
  options?: RequestInit,
): Promise<getStreaksMeResponse> => {
  return rnFetch<getStreaksMeResponse>(getGetStreaksMeUrl(params), {
    ...options,
    method: "GET",
  });
};

export const getGetStreaksMeQueryKey = (params?: GetStreaksMeParams) => {
  return [`/streaks/me`, ...(params ? [params] : [])] as const;
};

export const getGetStreaksMeQueryOptions = <
  TData = Awaited<ReturnType<typeof getStreaksMe>>,
  TError = Error,
>(
  params?: GetStreaksMeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStreaksMe>>, TError, TData>
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetStreaksMeQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getStreaksMe>>> = ({
    signal,
  }) => getStreaksMe(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStreaksMe>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetStreaksMeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getStreaksMe>>
>;
export type GetStreaksMeQueryError = Error;

export function useGetStreaksMe<
  TData = Awaited<ReturnType<typeof getStreaksMe>>,
  TError = Error,
>(
  params: undefined | GetStreaksMeParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStreaksMe>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStreaksMe>>,
          TError,
          Awaited<ReturnType<typeof getStreaksMe>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetStreaksMe<
  TData = Awaited<ReturnType<typeof getStreaksMe>>,
  TError = Error,
>(
  params?: GetStreaksMeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStreaksMe>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStreaksMe>>,
          TError,
          Awaited<ReturnType<typeof getStreaksMe>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetStreaksMe<
  TData = Awaited<ReturnType<typeof getStreaksMe>>,
  TError = Error,
>(
  params?: GetStreaksMeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStreaksMe>>, TError, TData>
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetStreaksMe<
  TData = Awaited<ReturnType<typeof getStreaksMe>>,
  TError = Error,
>(
  params?: GetStreaksMeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getStreaksMe>>, TError, TData>
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetStreaksMeQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export type getStreaksHistoryResponse200 = {
  data: GetStreaksHistory200;
  status: 200;
};

export type getStreaksHistoryResponse500 = {
  data: Error;
  status: 500;
};

export type getStreaksHistoryResponseSuccess = getStreaksHistoryResponse200 & {
  headers: Headers;
};
export type getStreaksHistoryResponseError = getStreaksHistoryResponse500 & {
  headers: Headers;
};

export type getStreaksHistoryResponse =
  | getStreaksHistoryResponseSuccess
  | getStreaksHistoryResponseError;

export const getGetStreaksHistoryUrl = (params?: GetStreaksHistoryParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/streaks/history?${stringifiedParams}`
    : `/streaks/history`;
};

export const getStreaksHistory = async (
  params?: GetStreaksHistoryParams,
  options?: RequestInit,
): Promise<getStreaksHistoryResponse> => {
  return rnFetch<getStreaksHistoryResponse>(getGetStreaksHistoryUrl(params), {
    ...options,
    method: "GET",
  });
};

export const getGetStreaksHistoryQueryKey = (
  params?: GetStreaksHistoryParams,
) => {
  return [`/streaks/history`, ...(params ? [params] : [])] as const;
};

export const getGetStreaksHistoryQueryOptions = <
  TData = Awaited<ReturnType<typeof getStreaksHistory>>,
  TError = Error,
>(
  params?: GetStreaksHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getStreaksHistory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetStreaksHistoryQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getStreaksHistory>>
  > = ({ signal }) => getStreaksHistory(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getStreaksHistory>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetStreaksHistoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getStreaksHistory>>
>;
export type GetStreaksHistoryQueryError = Error;

export function useGetStreaksHistory<
  TData = Awaited<ReturnType<typeof getStreaksHistory>>,
  TError = Error,
>(
  params: undefined | GetStreaksHistoryParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getStreaksHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStreaksHistory>>,
          TError,
          Awaited<ReturnType<typeof getStreaksHistory>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetStreaksHistory<
  TData = Awaited<ReturnType<typeof getStreaksHistory>>,
  TError = Error,
>(
  params?: GetStreaksHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getStreaksHistory>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getStreaksHistory>>,
          TError,
          Awaited<ReturnType<typeof getStreaksHistory>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetStreaksHistory<
  TData = Awaited<ReturnType<typeof getStreaksHistory>>,
  TError = Error,
>(
  params?: GetStreaksHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getStreaksHistory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};

export function useGetStreaksHistory<
  TData = Awaited<ReturnType<typeof getStreaksHistory>>,
  TError = Error,
>(
  params?: GetStreaksHistoryParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getStreaksHistory>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetStreaksHistoryQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get user notifications
 */
export type getNotificationsResponse200 = {
  data: GetNotifications200Item[];
  status: 200;
};

export type getNotificationsResponseSuccess = getNotificationsResponse200 & {
  headers: Headers;
};
export type getNotificationsResponse = getNotificationsResponseSuccess;

export const getGetNotificationsUrl = (params?: GetNotificationsParams) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `/notifications?${stringifiedParams}`
    : `/notifications`;
};

export const getNotifications = async (
  params?: GetNotificationsParams,
  options?: RequestInit,
): Promise<getNotificationsResponse> => {
  return rnFetch<getNotificationsResponse>(getGetNotificationsUrl(params), {
    ...options,
    method: "GET",
  });
};

export const getGetNotificationsQueryKey = (
  params?: GetNotificationsParams,
) => {
  return [`/notifications`, ...(params ? [params] : [])] as const;
};

export const getGetNotificationsQueryOptions = <
  TData = Awaited<ReturnType<typeof getNotifications>>,
  TError = unknown,
>(
  params?: GetNotificationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNotifications>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNotificationsQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNotifications>>
  > = ({ signal }) => getNotifications(params, { signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getNotifications>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetNotificationsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNotifications>>
>;
export type GetNotificationsQueryError = unknown;

export function useGetNotifications<
  TData = Awaited<ReturnType<typeof getNotifications>>,
  TError = unknown,
>(
  params: undefined | GetNotificationsParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNotifications>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotifications>>,
          TError,
          Awaited<ReturnType<typeof getNotifications>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNotifications<
  TData = Awaited<ReturnType<typeof getNotifications>>,
  TError = unknown,
>(
  params?: GetNotificationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNotifications>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotifications>>,
          TError,
          Awaited<ReturnType<typeof getNotifications>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNotifications<
  TData = Awaited<ReturnType<typeof getNotifications>>,
  TError = unknown,
>(
  params?: GetNotificationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNotifications>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get user notifications
 */

export function useGetNotifications<
  TData = Awaited<ReturnType<typeof getNotifications>>,
  TError = unknown,
>(
  params?: GetNotificationsParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNotifications>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetNotificationsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get unread notifications count
 */
export type getNotificationsUnreadCountResponse200 = {
  data: GetNotificationsUnreadCount200;
  status: 200;
};

export type getNotificationsUnreadCountResponseSuccess =
  getNotificationsUnreadCountResponse200 & {
    headers: Headers;
  };
export type getNotificationsUnreadCountResponse =
  getNotificationsUnreadCountResponseSuccess;

export const getGetNotificationsUnreadCountUrl = () => {
  return `/notifications/unread-count`;
};

export const getNotificationsUnreadCount = async (
  options?: RequestInit,
): Promise<getNotificationsUnreadCountResponse> => {
  return rnFetch<getNotificationsUnreadCountResponse>(
    getGetNotificationsUnreadCountUrl(),
    {
      ...options,
      method: "GET",
    },
  );
};

export const getGetNotificationsUnreadCountQueryKey = () => {
  return [`/notifications/unread-count`] as const;
};

export const getGetNotificationsUnreadCountQueryOptions = <
  TData = Awaited<ReturnType<typeof getNotificationsUnreadCount>>,
  TError = unknown,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getNotificationsUnreadCount>>,
      TError,
      TData
    >
  >;
  request?: SecondParameter<typeof rnFetch>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetNotificationsUnreadCountQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getNotificationsUnreadCount>>
  > = ({ signal }) =>
    getNotificationsUnreadCount({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof getNotificationsUnreadCount>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetNotificationsUnreadCountQueryResult = NonNullable<
  Awaited<ReturnType<typeof getNotificationsUnreadCount>>
>;
export type GetNotificationsUnreadCountQueryError = unknown;

export function useGetNotificationsUnreadCount<
  TData = Awaited<ReturnType<typeof getNotificationsUnreadCount>>,
  TError = unknown,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNotificationsUnreadCount>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotificationsUnreadCount>>,
          TError,
          Awaited<ReturnType<typeof getNotificationsUnreadCount>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNotificationsUnreadCount<
  TData = Awaited<ReturnType<typeof getNotificationsUnreadCount>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNotificationsUnreadCount>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getNotificationsUnreadCount>>,
          TError,
          Awaited<ReturnType<typeof getNotificationsUnreadCount>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGetNotificationsUnreadCount<
  TData = Awaited<ReturnType<typeof getNotificationsUnreadCount>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNotificationsUnreadCount>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get unread notifications count
 */

export function useGetNotificationsUnreadCount<
  TData = Awaited<ReturnType<typeof getNotificationsUnreadCount>>,
  TError = unknown,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getNotificationsUnreadCount>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetNotificationsUnreadCountQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Mark notification as read
 */
export type patchNotificationsIdReadResponse200 = {
  data: PatchNotificationsIdRead200;
  status: 200;
};

export type patchNotificationsIdReadResponseSuccess =
  patchNotificationsIdReadResponse200 & {
    headers: Headers;
  };
export type patchNotificationsIdReadResponse =
  patchNotificationsIdReadResponseSuccess;

export const getPatchNotificationsIdReadUrl = (id: string) => {
  return `/notifications/${id}/read`;
};

export const patchNotificationsIdRead = async (
  id: string,
  options?: RequestInit,
): Promise<patchNotificationsIdReadResponse> => {
  return rnFetch<patchNotificationsIdReadResponse>(
    getPatchNotificationsIdReadUrl(id),
    {
      ...options,
      method: "PATCH",
    },
  );
};

export const getPatchNotificationsIdReadMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patchNotificationsIdRead>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patchNotificationsIdRead>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ["patchNotificationsIdRead"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patchNotificationsIdRead>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return patchNotificationsIdRead(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatchNotificationsIdReadMutationResult = NonNullable<
  Awaited<ReturnType<typeof patchNotificationsIdRead>>
>;

export type PatchNotificationsIdReadMutationError = unknown;

/**
 * @summary Mark notification as read
 */
export const usePatchNotificationsIdRead = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof patchNotificationsIdRead>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof patchNotificationsIdRead>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getPatchNotificationsIdReadMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Mark all notifications as read
 */
export type patchNotificationsReadAllResponse200 = {
  data: PatchNotificationsReadAll200;
  status: 200;
};

export type patchNotificationsReadAllResponseSuccess =
  patchNotificationsReadAllResponse200 & {
    headers: Headers;
  };
export type patchNotificationsReadAllResponse =
  patchNotificationsReadAllResponseSuccess;

export const getPatchNotificationsReadAllUrl = () => {
  return `/notifications/read-all`;
};

export const patchNotificationsReadAll = async (
  options?: RequestInit,
): Promise<patchNotificationsReadAllResponse> => {
  return rnFetch<patchNotificationsReadAllResponse>(
    getPatchNotificationsReadAllUrl(),
    {
      ...options,
      method: "PATCH",
    },
  );
};

export const getPatchNotificationsReadAllMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patchNotificationsReadAll>>,
    TError,
    void,
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof patchNotificationsReadAll>>,
  TError,
  void,
  TContext
> => {
  const mutationKey = ["patchNotificationsReadAll"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patchNotificationsReadAll>>,
    void
  > = () => {
    return patchNotificationsReadAll(requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PatchNotificationsReadAllMutationResult = NonNullable<
  Awaited<ReturnType<typeof patchNotificationsReadAll>>
>;

export type PatchNotificationsReadAllMutationError = unknown;

/**
 * @summary Mark all notifications as read
 */
export const usePatchNotificationsReadAll = <
  TError = unknown,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof patchNotificationsReadAll>>,
      TError,
      void,
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof patchNotificationsReadAll>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getPatchNotificationsReadAllMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Delete a notification
 */
export type deleteNotificationsIdResponse200 = {
  data: DeleteNotificationsId200;
  status: 200;
};

export type deleteNotificationsIdResponseSuccess =
  deleteNotificationsIdResponse200 & {
    headers: Headers;
  };
export type deleteNotificationsIdResponse =
  deleteNotificationsIdResponseSuccess;

export const getDeleteNotificationsIdUrl = (id: string) => {
  return `/notifications/${id}`;
};

export const deleteNotificationsId = async (
  id: string,
  options?: RequestInit,
): Promise<deleteNotificationsIdResponse> => {
  return rnFetch<deleteNotificationsIdResponse>(
    getDeleteNotificationsIdUrl(id),
    {
      ...options,
      method: "DELETE",
    },
  );
};

export const getDeleteNotificationsIdMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteNotificationsId>>,
    TError,
    { id: string },
    TContext
  >;
  request?: SecondParameter<typeof rnFetch>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteNotificationsId>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ["deleteNotificationsId"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteNotificationsId>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {};

    return deleteNotificationsId(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteNotificationsIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteNotificationsId>>
>;

export type DeleteNotificationsIdMutationError = unknown;

/**
 * @summary Delete a notification
 */
export const useDeleteNotificationsId = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteNotificationsId>>,
      TError,
      { id: string },
      TContext
    >;
    request?: SecondParameter<typeof rnFetch>;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteNotificationsId>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getDeleteNotificationsIdMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
