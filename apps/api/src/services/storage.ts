import { Database } from "@/supabase-types";
import { SupabaseClient } from "@supabase/supabase-js";

const AVATAR_BUCKET = "profile-avatar";
const MEMORIES_BUCKET = "memories";
const ALBUM_PDF_BUCKET = "album-exports";

/** Turn the file name into an URL-compatible name. */
function urlify(name: string) {
  return name.replace(/[^a-zA-Z0-9_.-]/g, "_");
}

/**
 * Determines the media type folder based on file MIME type
 */
function getMediaTypeFolder(mimeType: string): string {
  if (mimeType.startsWith("image/")) {
    return "imagenes";
  } else if (mimeType.startsWith("video/")) {
    return "videos";
  } else if (mimeType.startsWith("audio/")) {
    return "audios";
  } else {
    return "otros"; // Para otros tipos de archivos
  }
}

/**
 * Uploads a profile avatar to Supabase Storage and returns the public URL.
 */
export async function uploadUserAvatarImage(
  supabase: SupabaseClient<Database>,
  userId: string,
  file: File
): Promise<string> {
  const originalName = file.name || `avatar-${Date.now()}`;
  const path = `${userId}/${Date.now()}-${urlify(originalName)}`;

  const { error } = await supabase.storage
    .from(AVATAR_BUCKET)
    .upload(path, file, {
      contentType: file.type || "application/octet-stream",
      upsert: true,
    });
  if (error) {
    throw new Error(`Upload failed: ${error.message}`);
  }

  const { data } = supabase.storage.from(AVATAR_BUCKET).getPublicUrl(path);
  return data.publicUrl;
}

/**
 * Uploads a memory media file to Supabase Storage organized by media type and returns the public URL.
 * Files are organized as: {groupId}/{mediaType}/{fileName}
 * Where mediaType can be: imagenes, videos, audios, otros
 */
export async function uploadMemoryImage(
  supabase: SupabaseClient<Database>,
  groupId: string,
  bookId: string,
  file: File
): Promise<string> {
  const originalName = file.name || `memory-${Date.now()}`;
  const fileExtension = originalName.split(".").pop() || "bin";
  const fileName = `${Date.now()}_${Math.random()
    .toString(36)
    .substring(2)}.${fileExtension}`;

  // Determinar el tipo de media y crear el path organizado
  const mediaTypeFolder = getMediaTypeFolder(
    file.type || "application/octet-stream"
  );
  const path = `${groupId}/${bookId}/${mediaTypeFolder}/${fileName}`;

  const { error } = await supabase.storage
    .from(MEMORIES_BUCKET)
    .upload(path, file, {
      contentType: file.type || "application/octet-stream",
      cacheControl: "3600",
      upsert: false,
    });

  if (error) {
    throw new Error(`Memory media upload failed: ${error.message}`);
  }

  const { data } = supabase.storage.from(MEMORIES_BUCKET).getPublicUrl(path);
  return data.publicUrl;
}

/**
 * Deletes a memory media object from Supabase Storage.
 * Expects a public URL produced by `getPublicUrl` for the `memories` bucket.
 */
export async function deleteMemoryMediaByPublicUrl(
  supabase: SupabaseClient<Database>,
  publicUrl: string
): Promise<void> {
  const normalizedUrl = publicUrl.split("?")[0] ?? publicUrl;
  const marker = `/storage/v1/object/public/${MEMORIES_BUCKET}/`;
  const index = normalizedUrl.indexOf(marker);

  if (index === -1) {
    throw new Error("Unsupported memories public URL format");
  }

  const path = normalizedUrl.substring(index + marker.length);
  if (!path) {
    throw new Error("Could not extract storage path from memories public URL");
  }

  const { error } = await supabase.storage.from(MEMORIES_BUCKET).remove([path]);
  if (error) {
    throw new Error(`Memory media delete failed: ${error.message}`);
  }
}
/**
 * Uploads an album cover image (generated by AI) to Supabase Storage and returns the public URL.
 * Files are organized as: album-covers/{groupId}/{albumId}/cover.png
 */
export async function uploadAlbumCoverImage(
  supabase: SupabaseClient<Database>,
  groupId: string,
  albumId: string,
  imageBuffer: Buffer
): Promise<string> {
  const path = `album-covers/${groupId}/${albumId}/cover.png`;

  const { error } = await supabase.storage
    .from(MEMORIES_BUCKET)
    .upload(path, imageBuffer, {
      contentType: "image/png",
      cacheControl: "3600",
      upsert: true,
    });

  if (error) {
    throw new Error(`Album cover image upload failed: ${error.message}`);
  }

  const { data } = supabase.storage.from(MEMORIES_BUCKET).getPublicUrl(path);
  return data.publicUrl;
}

/**
 * Uploads an album PDF export to Supabase Storage and returns the public URL.
 * Files are organized as: album-exports/{groupId}/{albumId}/{timestamp}.pdf
 */
export async function uploadAlbumPDF(
  supabase: SupabaseClient<Database>,
  groupId: string,
  albumId: string,
  pdfBuffer: Buffer
): Promise<string> {
  const timestamp = Date.now();
  const path = `${groupId}/${albumId}/${timestamp}.pdf`;

  const { error } = await supabase.storage
    .from(ALBUM_PDF_BUCKET)
    .upload(path, pdfBuffer, {
      contentType: "application/pdf",
      cacheControl: "3600",
      upsert: false,
    });

  if (error) {
    throw new Error(`Album PDF upload failed: ${error.message}`);
  }

  const { data } = supabase.storage.from(ALBUM_PDF_BUCKET).getPublicUrl(path);
  return data.publicUrl;
}