import { useState, useCallback, useMemo, useEffect, useRef } from "react";
import Animated, { ZoomIn } from "react-native-reanimated";
import {
  View,
  StyleSheet,
  FlatList,
  RefreshControl,
  Image,
  StatusBar,
} from "react-native";
import { Text, ActivityIndicator, Button, SegmentedButtons, IconButton } from "react-native-paper";
import { useSafeAreaInsets } from "react-native-safe-area-context";
import { useRouter } from "expo-router";
import { COLORS, STYLES } from "@/styles/base";
import { useAuth } from "@/hooks/useAuth";
import { useGetMemories, Album, useGetFamilyGroupIdGroupMembers, GetFamilyGroupIdGroupMembers200 } from "@elepad/api-client";
import CreateAlbumDialog from "@/components/Recuerdos/CreateAlbumDialog";
import AlbumCard from "@/components/shared/AlbumCard";
import { useAlbumCreation } from "@/hooks/useAlbumCreation";
import { BackButton } from "@/components/shared/BackButton";
import eleEmpthy from "@/assets/images/EleUltimatePack/ele-polaroids-pensativo.png";
import { usePendingAlbums, PendingAlbum } from "@/hooks/usePendingAlbums";

const unwrapAlbums = (response: unknown): Album[] => {
  let cursor: unknown = response;

  while (cursor !== undefined && cursor !== null) {
    if (Array.isArray(cursor)) {
      return cursor as Album[];
    }

    if (typeof cursor === "object" && cursor !== null && "data" in cursor) {
      cursor = (cursor as { data?: unknown }).data;
      continue;
    }

    break;
  }

  return [];
};

export default function AlbumsScreen() {
  const { userElepad } = useAuth();
  const router = useRouter();
  const groupId = userElepad?.groupId || "";

  const [albumDialogVisible, setAlbumDialogVisible] = useState(false);
  const [refreshing, setRefreshing] = useState(false);
  const [sortOrder, setSortOrder] = useState<"desc" | "asc">("desc");
  const [numColumns, setNumColumns] = useState(1);

  // Fetch albums using the custom hook
  const { albumsQuery } = useAlbumCreation();
  const insets = useSafeAreaInsets();

  // Fetch memories for the album creation
  const { data: memoriesResponse } = useGetMemories(
    {
      groupId,
      limit: 100,
    },
    {
      query: {
        enabled: !!groupId,
      },
    },
  );

  const memories = Array.isArray(memoriesResponse?.data)
    ? memoriesResponse.data
    : [];

  // Fetch family members for the preview
  const membersQuery = useGetFamilyGroupIdGroupMembers(groupId, {
    query: { enabled: !!groupId },
  });

  const selectGroupInfo = (): GetFamilyGroupIdGroupMembers200 | undefined => {
    const resp = membersQuery.data as
      | { data?: GetFamilyGroupIdGroupMembers200 }
      | GetFamilyGroupIdGroupMembers200
      | undefined;
    if (!resp) return undefined;
    return (
      (resp as { data?: GetFamilyGroupIdGroupMembers200 }).data ??
      (resp as GetFamilyGroupIdGroupMembers200)
    );
  };

  const groupInfo = selectGroupInfo();
  const groupMembers = useMemo(() => {
    if (!groupInfo)
      return [] as Array<{
        id: string;
        displayName: string;
        avatarUrl?: string | null;
        activeFrameUrl?: string | null;
      }>;

    const raw = [groupInfo.owner, ...groupInfo.members];
    const byId = new Map<
      string,
      {
        id: string;
        displayName: string;
        avatarUrl?: string | null;
        activeFrameUrl?: string | null;
      }
    >();
    for (const m of raw) {
      if (!m?.id) continue;
      byId.set(m.id, {
        id: m.id,
        displayName: m.displayName,
        avatarUrl: m.avatarUrl ?? null,
        activeFrameUrl: m.activeFrameUrl ?? null,
      });
    }
    return Array.from(byId.values());
  }, [groupInfo]);

  // Extract albums from the query
  const albums: Album[] = unwrapAlbums(albumsQuery.data);

  // ‚îÄ‚îÄ Pending albums (being generated by AI) ‚îÄ‚îÄ
  const { pendingAlbums, removePendingAlbumByTitle } = usePendingAlbums();

  // When the real album list changes, check if any pending album has been created
  // and remove it from the pending list.
  const prevAlbumTitlesRef = useRef<Set<string>>(new Set());
  useEffect(() => {
    if (albums.length === 0 && pendingAlbums.length === 0) return;

    const currentTitles = new Set(albums.map((a) => a.title.trim().toLowerCase()));

    for (const pending of pendingAlbums) {
      if (currentTitles.has(pending.title.trim().toLowerCase())) {
        console.log("‚úÖ √Ålbum generado detectado, quitando preview:", pending.title);
        removePendingAlbumByTitle(pending.title);
      }
    }

    prevAlbumTitlesRef.current = currentTitles;
  }, [albums, pendingAlbums, removePendingAlbumByTitle]);

  // Poll for new albums while there are pending ones
  useEffect(() => {
    if (pendingAlbums.length === 0) return;

    const interval = setInterval(() => {
      console.log("üîÑ Polling √°lbumes (hay pendientes)...");
      albumsQuery.refetch();
    }, 15000); // every 15s

    return () => clearInterval(interval);
  }, [pendingAlbums.length, albumsQuery]);

  // Build combined list: pending first, then real albums
  type ListItem =
    | { type: "pending"; pending: PendingAlbum }
    | { type: "album"; album: Album };

  const listData: ListItem[] = useMemo(() => {
    // Sort real albums by createdAt
    const sorted = [...albums].sort((a, b) => {
      const dateA = new Date(a.createdAt).getTime();
      const dateB = new Date(b.createdAt).getTime();
      return sortOrder === "desc" ? dateB - dateA : dateA - dateB;
    });

    // Pending always first, then sorted albums
    const items: ListItem[] = pendingAlbums.map((p) => ({ type: "pending" as const, pending: p }));
    for (const album of sorted) {
      items.push({ type: "album" as const, album });
    }
    return items;
  }, [pendingAlbums, albums, sortOrder]);

  const handleAlbumPress = useCallback(
    (albumId: string) => {
      router.push(`/album-viewer?id=${albumId}`);
    },
    [router],
  );

  const onRefresh = useCallback(async () => {
    setRefreshing(true);
    await albumsQuery.refetch();
    setRefreshing(false);
  }, [albumsQuery]);

  return (
    <View
      style={[
        STYLES.safeArea,
        {
          paddingTop: insets.top,
          paddingLeft: insets.left,
          paddingRight: insets.right,
        },
      ]}
    >
      <StatusBar barStyle="dark-content" backgroundColor={COLORS.background} />

      {/* Header */}
      <View
        style={{
          paddingHorizontal: 24,
          paddingTop: 20,
          paddingBottom: 8,
          borderBottomColor: COLORS.border,
          flexDirection: "row",
          justifyContent: "space-between",
          alignItems: "center",
        }}
      >
        <View style={{ flexDirection: "row", alignItems: "center" }}>
          <BackButton size={28} onPress={() => router.back()} />
          <Text style={STYLES.superHeading}>√Ålbumes</Text>
        </View>
        <Button
          mode="contained"
          onPress={() => setAlbumDialogVisible(true)}
          style={{ ...STYLES.miniButton }}
          icon="plus"
        >
          Agregar
        </Button>
      </View>

      {/* Content */}
      <View style={styles.content}>
        {albumsQuery.isLoading && albums.length === 0 && pendingAlbums.length === 0 ? (
          <View style={styles.loadingContainer}>
            <ActivityIndicator size="large" color={COLORS.primary} />
            <Text style={{ ...STYLES.subheading, marginTop: 14 }}>
              Cargando √°lbumes...
            </Text>
          </View>
        ) : listData.length === 0 ? (
          <View style={styles.emptyContainer}>
            <Image source={eleEmpthy} style={styles.emptyImage} />
            <Text style={STYLES.heading}>No hay √°lbumes a√∫n</Text>
            <Text style={styles.emptyText}>
              Crea √°lbumes con narrativas generadas por IA a partir de tus
              recuerdos fotogr√°ficos.
            </Text>
          </View>
        ) : (
          <>
            {/* Controles de ordenamiento y vista */}
            <View
              style={{
                paddingHorizontal: 24,
                paddingVertical: 12,
                flexDirection: "row",
                alignItems: "center",
                justifyContent: "space-between",
              }}
            >
              {/* Toggle de Vistas - Izquierda */}
              <SegmentedButtons
                value={numColumns.toString()}
                onValueChange={(value) => setNumColumns(parseInt(value))}
                buttons={[
                  { value: "1", icon: "view-agenda" },
                  { value: "2", icon: "view-grid" },
                ]}
                density="small"
                style={{ maxWidth: 100 }}
                theme={{
                  colors: {
                    secondaryContainer: COLORS.primary,
                    onSecondaryContainer: COLORS.white,
                  },
                }}
              />

              {/* Bot√≥n de Ordenar - Derecha */}
              <IconButton
                icon={sortOrder === "desc" ? "arrow-down" : "arrow-up"}
                size={20}
                onPress={() =>
                  setSortOrder(sortOrder === "desc" ? "asc" : "desc")
                }
                mode="contained-tonal"
                style={{ margin: 0 }}
              />
            </View>

            <FlatList
              key={`albums-${numColumns}`}
              data={listData}
              keyExtractor={(item) =>
                item.type === "pending" ? item.pending.id : item.album.id
              }
              numColumns={numColumns}
              contentContainerStyle={styles.listContent}
              showsVerticalScrollIndicator={false}
              refreshControl={
                <RefreshControl
                  refreshing={refreshing}
                  onRefresh={onRefresh}
                  colors={[COLORS.primary]}
                />
              }
              renderItem={({ item, index }) => {
                if (item.type === "pending") {
                  return (
                    <Animated.View
                      entering={ZoomIn.delay(index * 25).springify()}
                      style={[
                        styles.columnItem,
                        numColumns === 2 && styles.columnItemHalf,
                      ]}
                    >
                      <AlbumCard
                        id={item.pending.id}
                        title={item.pending.title}
                        coverImageUrl={item.pending.coverPreviewUrl}
                        createdAt={new Date(item.pending.createdAt).toISOString()}
                        onPress={() => {}}
                        isPending
                        compact={numColumns === 2}
                      />
                    </Animated.View>
                  );
                }

                return (
                  <Animated.View
                    entering={ZoomIn.delay(index * 25).springify()}
                    style={[
                      styles.columnItem,
                      numColumns === 2 && styles.columnItemHalf,
                    ]}
                  >
                    <AlbumCard
                      id={item.album.id}
                      title={item.album.title}
                      description={item.album.description}
                      coverImageUrl={item.album.coverImageUrl}
                      pdfUrl={item.album.urlPdf}
                      createdAt={item.album.createdAt}
                      totalPages={undefined}
                      onPress={() => handleAlbumPress(item.album.id)}
                      compact={numColumns === 2}
                    />
                  </Animated.View>
                );
              }}
              ListFooterComponent={
                <View style={{ height: 40 }} />
              }
            />
          </>
        )}
      </View>

      {/* Di√°logo para crear √°lbum con IA */}
      <CreateAlbumDialog
        visible={albumDialogVisible}
        onDismiss={() => setAlbumDialogVisible(false)}
        memories={memories}
        familyMembers={groupMembers}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  content: {
    flex: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
  },
  emptyContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    paddingHorizontal: 40,
  },
  emptyImage: {
    width: 180,
    height: 180,
    borderRadius: 18,
    marginBottom: 16,
  },
  emptyText: {
    fontSize: 16,
    color: COLORS.textSecondary,
    textAlign: "center",
    marginTop: 8,
    marginBottom: 24,
    lineHeight: 24,
  },
  listContent: {
    paddingHorizontal: 24,
    paddingTop: 8,
  },
  columnItem: {
    width: "100%",
    marginBottom: 16,
  },
  columnItemHalf: {
    width: "50%",
    paddingHorizontal: 4,
  },
});
